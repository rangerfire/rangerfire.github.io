<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[God Bless Programmer]]></title>
    <url>%2F2028%2F05%2F08%2FNeverBug%2F</url>
    <content type="text"><![CDATA[_oo0oo_ _oo0oo_ o8888888o o8888888o 88&quot; . &quot;88 88&quot; . &quot;88 (| -_- |) (| -_- |) 0\ = /0 0\ = /0 ___/`---&apos;\___ ___/`---&apos;\___ .&apos; \\| |// &apos;. .&apos; \\| |// &apos;. / \\||| : |||// \ / \\||| : |||// \ / _||||| -:- |||||- \ / _||||| -:- |||||- \ | | \\\ - /// | | | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; |_/ | | \_| &apos;&apos;\---/&apos;&apos; |_/ | \ .-\__ &apos;-&apos; ___/-. / \ .-\__ &apos;-&apos; ___/-. / ___&apos;. .&apos; /--.--\ `. .&apos;___ ___&apos;. .&apos; /--.--\ `. .&apos;___ .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos; &quot;&quot;. .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos; &quot;&quot;. | | : `- \`.;`\ _ /`;.`/ - ` : | | | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `_. \_ __\ /__ _/ .-` / / \ \ `_. \_ __\ /__ _/ .-` / / =====`-.____`.___ \_____/___.-`___.-&apos;===== =====`-.____`.___ \_____/___.-`___.-&apos;===== `=---=&apos; `=---=&apos; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 写字楼里写字间，写字间里程序员； 程序人员写程序，又拿程序换酒钱。 酒醒只在网上坐，酒醉还来网下眠； 酒醉酒醒日复日，网上网下年复年。 但愿老死电脑间，不愿鞠躬老板前； 奔驰宝马贵者趣，公交自行程序员。 别人笑我忒疯癫，我笑自己命太贱； 不见满街漂亮妹，哪个归得程序员？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java中的拷贝和参数传递]]></title>
    <url>%2F2020%2F07%2F21%2FJava_Copy%2F</url>
    <content type="text"><![CDATA[参数传递 参数传递有2种：值传递，引用传递 值传递：形参接受的是实参的一个副本，所以在函数内对这个副本如何改变，都不会影响原始实参的值。 引用传递：实参的地址被传递给形参，函数内实参和形参指向同一个内存地址，所以形参的改变，同样会导致实参的改变。 回顾实参/形参： 如果在方法调用之前就被创建并初始化，它就是实参：比如int b = 10; f(b)；这个b就是实参，在函数里是没法用的（但是它进入函数前必须初始化）； 而在函数名字中的参数，是形参，在函数调用结束之后，会被释放：比如public void f(int a)中的这个a 数据类型：是编程语言对内存的一种抽象表达方式，规定了一个类型的数据的存储形式（即规定了如何将这类数据，转换到内存中执行） Java有8种基本数据类型：byte short int long, float double, char, boolean 除此之外，其他的都是引用类型（存放实际内容所在的地址），比如数组，类，接口 好，先了解一下JVM是如何保存数据的：其中： 虚拟机栈里包含多个栈，每个函数都会有一个栈，（加载时弹入，运行结束时弹出）比如main函数就会有一个栈，存放它的局部变量。 堆只有一个，线程共享，存放对象和数组 JVM根据不同的数据类型，有不同的存储形式：对于基本数据类型，直接存在栈中，对于引用类型，对象存在堆中，栈中存放的是这个对象的地址。所以，age,weight,grade这3个基本数据类型就是直接存在栈中，而且允许多个变量指向同一个值（age,weight初始都是50）。当我们需要改变weight的时候，比如weight = 40;这时，在栈中寻找有没有40，没有的话，新建一个40，然后weight指向它。代码为： 123456789101112 public class Person&#123; private int age; private String name; private int grade; static void run() &#123; System.out.println("run...."); &#125;&#125;//main中的调用：Person per = new Person(); 而对于引用类型中的基本数据类型的成员变量，它的名字和值是存在堆中的，生命周期和这个引用数据类型相同，而且栈中存放的，是这个引用变量的地址，指向堆中这个对象的位置，而不是真实的值（与基本数据类型不同） 所以对于下列代码：123456789101112131415161718public static void valueCrossTest(int age,float weight)&#123; System.out.println("传入的age："+age); System.out.println("传入的weight："+weight); age=33; weight=89.5f; System.out.println("方法内重新赋值后的age："+age); System.out.println("方法内重新赋值后的weight："+weight);&#125;public static void main(String[] args) &#123; int a=25; float w=77.5f; valueCrossTest(a,w); System.out.println("方法执行后的age："+a); System.out.println("方法执行后的weight："+w);&#125; 所有改变都是在当前valueCrossTest函数的栈中的改变，不会影响原始的实参： 但是，我们知道，当我们把一个引用类型传递给形参时，比如上面的per，我们如果改变per.name，在外部函数中，是可以看到name被改变了的，但是这并不是引用传递，只是形参和实参指向的是同一个对象罢了。比如：1234567891011121314public static void PersonCrossTest(Person person)&#123; System.out.println("传入的person的name："+person.getName()); person.setName("我是张小龙"); System.out.println("方法内重新赋值后的name："+person.getName());&#125;public static void main(String[] args) &#123; Person p=new Person(); p.setName("我是马化腾"); p.setAge(45); PersonCrossTest(p); System.out.println("方法执行后的name："+p.getName());&#125; main中存放了per变量，并且存有一个指向堆中的那个对象的地址，而函数PersonCrossTest函数中的person对象得到了这个地址的复制，所以也指向该对象，当然，修改这个对象的内部成员变量，会改变per，因为它们指向同一个对象。如果，在test函数中增加一个person = new person();那么，这个person会指向一个新的对象，这时候，改变person，当然不会影响到原来的per对象： 所以，java中都是值传递，不管是基本类型，还是引用类型的传递。 关于String 无法通过函数改变的问题：明明String是引用类型，为什么外部的String无法通过函数改变值？首先，String确实是引用类型，它实际上是final修饰的一个char[]数组，所以它一定是引用类型。但是，String比较特殊的地方是，虽然，它传递的是一个地址，但是只要它在函数内部改变了，都会新建一个临时的对象，然后指向它，而外部对象所对应的那个地址，是不会变的，所以无法通过函数，来改变String类型的值。也就是： 1234567891011String s1 = "hello"; System.out.println(s1); modst(s1); System.out.println(s1); //改变text指向public static String modst(String text) &#123; return text = "sdf";&#125;//这里 text 一开始指向的是“hello”的地址，但是在函数中text改变了，这时，会新建一个“sdf”对象，text指向这个新的对象的地址，而s1还是原来的“hello”的地址，所以改变不了//这也是为什么String对象有时会表现出基本数据类型的特点 拷贝 对象拷贝（object copy）：将一个对象的属性拷贝到另一个相同类型的对象中去 Java中有三种拷贝：浅拷贝（shallow copy），深拷贝（deep copy），延迟拷贝（lazy copy） 通常情况下的对象赋值，也叫引用拷贝，而上面的几种其实全名是（对象）浅拷贝，（对象）深拷贝。 引用拷贝不会生成新的对象，只会在原对象上增加一个新的引用，它们指向的是同一个对象，修改会互相影响。（比如新建一个head节点 = root节点，它只是新建了一个指向同一个节点的引用而已，修改head也会影响root） 浅拷贝 对于要被拷贝的对象，如果它有基本数据类型的属性，则拷贝这个基本数据类型的值；如果它有引用数据类型的属性，则拷贝指向这个引用类型的地址。（也就是说：改变这个拷贝后的引用类型，会影响原始对象） 举例：一个对象Ob，它有int型的属性name，和引用型的属性int[] arr，那么如果创建一个Ob的浅拷贝对象，Ob_copy，结果如下： 如何实现浅拷贝：（只列了属性）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Subject类public class Subject &#123; private String name; public Subject(String s) &#123; name = s; &#125; &#125;//Student主类public class Student implements Cloneable &#123; private String name; private Subject subj; public Student(String s, String sub) &#123; name = s; subj = new Subject(sub); &#125; public Object clone() &#123; //浅拷贝 try &#123; // 直接调用父类的clone()方法 return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; return null; &#125; &#125; &#125;//测试函数private void test()&#123; // 原始对象 Student stud = new Student("小王", "原始"); System.out.println("原始对象: " + stud.getName() + " - " + stud.getSubj().getName()); // 拷贝对象 Student clonedStud = (Student) stud.clone(); System.out.println("拷贝对象: " + clonedStud.getName() + " - " + clonedStud.getSubj().getName()); // 原始对象和拷贝对象是否一样： System.out.println("原始对象和拷贝对象是否一样: " + (stud == clonedStud)); // 原始对象和拷贝对象的name属性是否一样 System.out.println("原始对象和拷贝对象的name属性是否一样: " + (stud.getName() == clonedStud.getName())); // 原始对象和拷贝对象的subj属性是否一样 System.out.println("原始对象和拷贝对象的subj属性是否一样: " + (stud.getSubj() == clonedStud.getSubj())); stud.setName("小李"); stud.getSubj().setName("更新"); System.out.println("更新后的原始对象: " + stud.getName() + " - " + stud.getSubj().getName()); System.out.println("更新原始对象后的克隆对象: " + clonedStud.getName() + " - " + clonedStud.getSubj().getName());&#125; 结果：原始对象: 小王 - 原始拷贝对象: 小王 - 原始原始对象和拷贝对象是否一样: false原始对象和拷贝对象的name属性是否一样: true原始对象和拷贝对象的subj属性是否一样: true更新后的原始对象: 小李 - 更新更新原始对象后的克隆对象: 小王 - 更新 以上例子足以说明浅拷贝的特点，与之前的参数传递也有异曲同工之妙 深拷贝 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 深拷贝对于引用对象也是新建一个对象并指向它，并不是原来的拷贝地址： 把原来的copy部分改成：12345public Object clone() &#123; Student s = new Student(name, subj.getName()); return s;&#125; 这样就是深拷贝了。 结果会变为：原始对象: 小王 - 原始拷贝对象: 小王 - 原始原始对象和拷贝对象是否一样: false原始对象和拷贝对象的name属性是否一样: true原始对象和拷贝对象的subj属性是否一样: false =&gt; 变了更新后的原始对象: 小李 - 更新更新原始对象后的克隆对象: 小王 - 原始 =&gt; 变了 序列化属于深拷贝 延迟拷贝 是浅拷贝和深拷贝的结合 存在一个计数器，开始时先用浅拷贝，（速度快），计数器统计有多少对象共享这个数据，并且当程序想要修改原始对象的时候，他会决定数据是否共享并根据需要进行深拷贝 外表来看是深拷贝 由于存在计数器，开销会大一些]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>INTERVIEW</tag>
        <tag>FUNDAMENT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree详解]]></title>
    <url>%2F2020%2F07%2F19%2FJava_Tree%2F</url>
    <content type="text"><![CDATA[基本概念 节点的度：该节点含有的子树的个数 树的度： Max(各个节点的度) 节点的层次：根节点算第0/1层，以此类推 树的高度：自底向上计算↑ 树的深度：自顶向下计算↓ 节点的高度和深度可能不同，树的高度和深度一定相同 两种实现方式：数组/链表 不要把树看成一个整体，每个节点都是一个单独的个体，它通过左右节点来和其他节点相联系，也可以通过父节点的左右节点来找到它，所以在拷贝它的时候，不要把它想成多复杂的结构。 二叉树 完全二叉树：A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.(除了最后一层，其它层全满，并且最后一层节点从左到右排列，没有间隔)注：完全二叉树如果用数组来存储，可以轻松确定父节点，子节点的位置 满二叉树：A full binary tree is a tree in which every node other than the leaves has two children.(如果一棵树的深度为h，而且它具有2^h-1个节点，那它就是一个满二叉树) 数组是将元素连续的排列在内存中，而二叉树不是采用连续的内存存放。因为对于每个节点，它总是知道下一个节点在哪，所以没必要连续存放。 二叉树的DFS有三种方法，前序，中序，后序。为递归的写法。其中，中序遍历可以用之前的Morris方法。 二叉查找树BST（Binary Search Tree） 基本特性：左子树所有节点 &lt; 根 &lt; 右子树所有节点 基本特性：查找效率 O（log2 n）简写为 O（lg n），随着n的增加，查找时间并没有增加太快，基本上是一条直线，比线性时间O（n）要好很多。但是这也比较依赖于树的拓扑结构，如果这个树只有右节点（像morris方法处理完之后的树），那么它的查找也为O（n），并不能减少比较的次数。 BST的插入操作：插入的节点一定是叶子节点，而寻找这个叶子节点的位置就是一个查找的过程 BST的删除操作：先定位（查找操作），然后分三种情况，它没有右孩子/它的右孩子没有左孩子/它的右孩子有左孩子，本质上都是找它右边最小的节点，来替换这个要删除的节点 平衡二叉查找树（Balanced Binary Search Tree） 典型：AVL树，最早被发明的自平衡二叉查找树，由发现者名字命名 目的：保证树不太倾斜，提高查找效率（即改善树的拓扑结构） 定义：1.要么是一棵空树 2.要么左右子树高度之差不大于1 3.子树必须也是平衡二叉树 平衡因子：Balance Factor：一个节点的平衡因子就是它的左子树的高度-右子树的高度的绝对值，每个节点的BF要小于等于1 操作：需要在插入和删除的时候进行调整 四种失衡的状况： 在N节点的左子树的左子树上插入一个节点，导致N节点的平衡因子变成了2，也叫LL插入，包括在左子树的左子树的左边和右边插入2种情况 在N节点的左子树的右子树上插入一个节点，也叫LR插入，同样包含两种情况 在N节点的右子树的左子树上插入，也叫RL插入，2种情况 在N节点的右子树的右子树上插入，也叫RR插入，2种情况 处理四种失衡的方法：（寻找最小不平衡树，判断类别，对应操作） LL：将N节点的左孩子作为新的“根节点”，将树顺时针旋转，旋转之后，N节点成为（原N的左孩子）的右孩子，（原N的左孩子的右孩子）变成了A的左孩子12345678910111213141516private TreeNode&lt;T&gt; leftRotate(TreeNode&lt;T&gt; node) &#123; // 将失衡结点的左子树赋给一个临时结点，也就是将N的左子树B 赋给新的结点 TreeNode&lt;T&gt; newRoot = node.leftChild; // 将B的右子树BR 挂在N 的左子树上 node.leftChild = newRoot.rightChild; // B 的右子树为失衡的结点即N newRoot.rightChild = node; // 结点N 的高度为左右子树高度最大值加1 node.height = getMax( height(node.leftChild), height(node.rightChild) ) + 1; // 结点B 的高度为左右子树高度最大值加1 newRoot.height = getMax( height(newRoot.leftChild), newRoot.height) + 1; // 返回根节点 return newRoot;&#125; RR：与LL相似，逆时针旋转12345678910111213141516private TreeNode&lt;T&gt; rightRotate(TreeNode&lt;T&gt; node) &#123; // 将失衡结点的右子树赋给一个临时结点，也就是将N的右子树B 赋给新的结点 TreeNode&lt;T&gt; newRoot = node.rightChild; // 将B的左子树BL 挂在N 的右子树上 node.rightChild = newRoot.leftChild; // B 的左子树为失衡的结点即N newRoot.leftChild = node; // 结点N 的高度为左右子树高度最大值加1 node.height = getMax( height(node.leftChild), height(node.rightChild) ) + 1; // 结点B 的高度为左右子树高度最大值加1 newRoot.height = getMax( height(newRoot.rightChild), newRoot.height) + 1; // 返回根节点 return newRoot;&#125; LR：需要借助上面2个旋转 =&gt; 即左-右双旋因为是在N节点左子树的右子树上插入，所以，先以N节点的左孩子为轴，进行LL操作；然后再以N节点为轴，进行RR操作。123456private TreeNode&lt;T&gt; leftrightRotate(TreeNode&lt;T&gt; node) &#123; node.leftChild = leftRotate( node.leftChild ); return rightRotate(node);&#125; RL：也需要借助之前2个旋转 =&gt; 即右-左双旋因为是在N节点右子树的左子树上插入，所以，先以N节点的右孩子为轴，进行RR操作；然后再以N节点为轴，进行LL操作。123456private TreeNode&lt;T&gt; rightleftRotate(TreeNode&lt;T&gt; node) &#123; node.rightChild = rightRotate( node.rightChild ); return leftRotate(node);&#125; 一个实现的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//TreeNode定义public class TreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T data; public TreeNode&lt;T&gt; leftChild; public TreeNode&lt;T&gt; rightChild; //当前结点的高度 public int height; //3个构造器 public TreeNode(T data) &#123; this(null, data, null); &#125; public TreeNode(TreeNode leftChild, T data, TreeNode rightChild) &#123; this(data, leftChild, rightChild, 0); &#125; public TreeNode(T data, TreeNode&lt;T&gt; leftChild, TreeNode&lt;T&gt; rightChild, int height) &#123; this.data = data; this.leftChild = leftChild; this.rightChild = rightChild; this.height = height; &#125; public T getData() &#123; return data; &#125; public TreeNode&lt;T&gt; getLeftChild() &#123; return leftChild; &#125; public TreeNode&lt;T&gt; getRightChild() &#123; return rightChild; &#125; public void setData(T data) &#123; this.data = data; &#125; public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125;&#125;//插入public void insert(T value) &#123; root = insert(root, value);&#125;private TreeNode&lt;T&gt; insert(TreeNode&lt;T&gt; node, T value) &#123; if (node == null) &#123; node = new TreeNode&lt;T&gt;(value); if (node == null) return null; &#125; else &#123; int cmp = value.compareTo(node.getData()); if (cmp &lt; 0) &#123; // 应该将value插入到"node的左子树"的情况 node.leftChild = insert(node.leftChild, value); // 插入节点后，若AVL树失去平衡，则进行相应的调节。 if (height(node.leftChild) - height(node.rightChild) == 2) &#123; if (value.compareTo(node.leftChild.getData()) &lt; 0) node = leftRotate(node); else node = leftRightRotate(node); &#125; &#125; else if (cmp &gt; 0) &#123; // 应该将value插入到"node的右子树"的情况 node.rightChild = insert(node.rightChild, value); // 插入节点后，若AVL树失去平衡，则进行相应的调节。 if (height(node.rightChild) - height(node.leftChild) == 2) &#123; if (value.compareTo(node.rightChild.getData()) &gt; 0) node = rightRotate(node); else node = rightLeftRotate(node); &#125; &#125; else // cmp==0 System.out.println("添加失败：不允许添加相同的节点！"); &#125; node.height = getMax(height(node.leftChild), height(node.rightChild)) + 1; return node;&#125; B-tree 相当于一个一般化的BST，即它可以拥有2个以上的子节点 不同于self-balanced BST，B树为系统大块数据的读写做了优化，通常用在数据库和文件系统的实现上。比如，对于二叉树，如果节点数量过多，则会使树的深度很大，从而降低查找效率，这时候，二叉变多叉就可以最简单的解决问题。（想象一下文件系统） 一个M阶B树是什么： 注：M阶指的是M叉查找树，例如M = 2，则为二叉查找树。 数据项存储在树叶上 非叶节点存储直到M-1个关键字以指示搜索方向：关键字代表子树i+1中最小的关键字 树的根或者是一片树叶，或者其儿子数都在2和M之间。 除根外，所有非树叶节点的儿子树在M/2与M之间。 所有的树叶都在相同的深度上拥有的数据项都在L/2与L之间。 B树的每个节点的子节点个数是预先设置好的，它是一个范围，所以不需要像平衡树一样频繁的更新，但是它的内部节点会根据情况分离或者合并。 B树每个内部节点都会有一堆Key值，用来区分子节点，比如一个节点N有4个子节点（即N的度为4），那么它就需要3个Key来分开这4个子节点:(&lt;key1) (key1 ~ key2) (key2 ~ key3) (&gt;key3)，即第一个子树内的值都要小于key1 一般，Key的数量是在（树最小的度-1） ~ 2 *（树最小的度-1）之间。这也是为了方便分离和合并，也就是方便插入和删除，相当于预留出一些空间，插入的时候就会快很多（不需要大范围移动数据） B树通过约束所有叶子节点在同一深度，保持平衡！ （还是不太懂）]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>INTERVIEW</tag>
        <tag>FUNDAMENT</tag>
        <tag>LinkedList</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程详解]]></title>
    <url>%2F2020%2F07%2F05%2FJava_Threads%2F</url>
    <content type="text"><![CDATA[wait()/notify()/notifyAll() 这三个方法都是Object对象的，那就是每个对象都有的。（但是一般在多线程中才会用到） 为什么要用到这三个方法：比如，有2个线程，线程A是做报数操作，从1开始报数，直到100，线程B是当报数到100的时候输出“完成”。如果我们在线程B中用while（i==100）这种语句，那么CPU会一直在线程B中做判断操作，浪费资源，这时候我们就需要wait操作，如果不满足条件，先等着，等到有变化的时候，再让别的程序去叫醒它，也就是notify它 wait()方法：使当前执行代码的线程开始等待，将当前线程放入“预执行队列”，并且在wait()所在的代码处停止执行，直到接到通知或被中断。注意，在调用wait()之前，线程必须获得该对象的锁，因此只能在同步代码块/同步方法中调用wait()。wait()方法可以使调用该线程的方法释放共享资源的锁，从运行态变为等待态！ notify()方法：如果有多个线程等待，那么线程规划器随机挑选出一个wait的线程，对其发出通知notify()，并使它等待获取该对象的对象锁。注意”等待获取该对象的对象锁”，这意味着，即使收到了通知，wait的线程也不会马上获取对象锁，必须等待notify()方法的线程释放锁才可以。notify()方法将唤醒的线程从等待态变为 可运行状态。和wait()一样，notify()也要在同步方法/同步代码块中调用。 notifyAll()方法： 不是随机挑一个wait的线程，而是唤醒所有线程。 关于释放锁，wait方法会释放锁，而notify方法不释放锁，需要等到notify的线程运行完之后，才释放对象锁 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class MyThread1 extends Thread&#123; private Object lock; public MyThread1(Object lock) &#123; this.lock = lock; &#125; //override run() public void run() &#123; try &#123; synchronized(lock) &#123; System.out.println("start wait: " + System.currentTimeMillis() ); lock.wait(); System.out.println("end wait: " + System.currentTimeMillis() ); &#125; &#125;catch(Exception e) &#123; System.out.println(Thread.currentThread().getName() + " has exception"); &#125; &#125;&#125;class MyThread2 extends Thread&#123; private Object lock; public MyThread2(Object lock) &#123; this.lock = lock; &#125; public void run() &#123; try &#123; synchronized (lock) &#123; System.out.println("start notify: " + System.currentTimeMillis() ); lock.notify(); System.out.println("end notify: " + System.currentTimeMillis() ); &#125; &#125;catch(Exception e) &#123; System.out.println(Thread.currentThread().getName() + " has exception"); &#125; &#125;&#125;//main函数:public static void main(String[] args) throws InterruptedException &#123; // TODO Auto-generated method stub //simple wait/notify example Object lock = new Object(); //注意这里必须是同一个对象才有用 MyThread1 mt1 = new MyThread1(lock); MyThread2 mt2 = new MyThread2(lock); mt1.start(); Thread.sleep(3000); //否则看不出效果 mt2.start(); &#125; Thread.interrupt()方法: 简要介绍一下（之后详解） 该方法不是直接中断该线程，而是给这个线程一个提醒，线程内部可以捕获InterruptedException异常来应对中断，比如return或者改变共享变量的值等方法使其退出 它不会中断一个正在运行的线程（比如在wait()的线程是可以interrupt的） synchronized在获锁的过程中是不能被中断的，也就是说，产生了死锁，则不可能被中断 如果wait()方法和notify()/notifyAll()方法不在同步方法/同步代码块中被调用，那么虚拟机会抛出java.lang.IllegalMonitorStateException，注意一下。 其他]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>INTERVIEW</tag>
        <tag>FUNDAMENT</tag>
        <tag>Threads</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Queue详解]]></title>
    <url>%2F2020%2F07%2F03%2FJava_Queue%2F</url>
    <content type="text"><![CDATA[简介 Queue是一种数据结构，与stack不同，是实现先入先出功能的线性表。 常用方法： boolean add(E e): 队尾添加一个元素，如果队列满了，会抛出异常 boolean offer(E e): 队尾添加一个元素，队列满了，返回false，不会抛出异常 E remove(): 队头删除一个元素，并返回该元素的值，当队列为空的时候，抛出异常 E poll(): 队头删除一个元素，并返回该元素的值，当队列为空的时候，不会抛出异常，会返回一个null E element(): 返回队列头部的元素，不删除它，如果队列为空，抛出异常 E peek(): 返回队列头部的元素，不删除它，如果队列为空，返回null，不会抛出异常 E remove(E e): 删除值为e的最先出现的那个元素 Queue是一个接口，继承自Collection接口，需要被实现，PriorityQueue/ArrayDeque/LinkedList，都可以实现Queue接口，Dequeue是Queue的子接口，需要ArrayDeque/LinkedList实现 LinkedList不可以设置queue的容量，而ArrayDeque(int numElements)，PriorityQueue(int initialCapacity)是可以实现预设容量的 PriorityQueue 优先级队列在取出元素的时候，不是按照进入的顺序取的，它是按照大小来取的，默认从小到大排列，一般情况下需要重新写一下比较器 comparator PriorityQueue，逻辑上是用堆实现的（完全二叉树），默认的时候是最小堆，物理上使用的是动态数组实现的（ArrayList）,通过按照指定方式出队，来完成有序，也就是“优先级”的作用，所以，如果直接调用toString()方法，得到的结果并不是有序的，只有一个一个poll()出来，才是有序的！ 对于上述的toString()方法，结果为什么不是有序的，比如：offer()的顺序时5，-1, 3, 7; 那么由于它是按照最小堆的方法构成的，所以它是按照最小堆的结构去不断插入并调整行加的元素，而物理上它是数组的形式，所以它的过程是：[5] -&gt; [-1, 5] -&gt; [-1, 5, 3] -&gt; [-1, 5, 3, 7]；这就是当前这个queue的存放顺序，这也是符合最小堆不是完全有序的这个特性的，所以你此时调用toString()方法，它的结果是[-1, 5, 3, 7]，并不是我们想要的结果； 而当我们一个一个poll出来的时候，每次操作都会弹出堆顶的元素，然后再调整堆使它继续满足最小堆，这时，我们就可以得到正确顺序的结果！ PriorityQueue的默认容量是11，之后会根据情况选择扩容至2倍还是1.5倍 PriorityQueue内部主要属性：123456private static final int DEFAULT_INITIAL_CAPACITY = 11; //默认用于存储节点信息的数组的大小transient Object[] queue; //用于存储节点信息的数组private int size = 0; //数组中实际存放元素的个数private final Comparator&lt;? super E&gt; comparator; //Comparator比较器transient int modCount = 0; //用于记录修改次数的变量 PriorityQueue的构造器：12345678910111213141516public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null);&#125;public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null);&#125;public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator);&#125;public PriorityQueue(int initialCapacity,Comparator&lt;? super E&gt; comparator) &#123; if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator;&#125; 实际上前面三种构造器，最后都会调用第四个构造器。 对于PriorityQueue中的增删改查操作，它们在内部就是最大堆或者最小堆的增删改查操作，（注意add方法内部也调用了offer方法），添加上面已经说过，删除一个节点的步骤为先判断是不是尾节点，是就直接删除，否则用记录最后一个节点的值，用它覆盖要删除的节点的值，然后先向下检查并修改使它们满足堆结构，再向上修改，使它们满足最小最大堆要求即可。出队则相当于删除头节点，依次向下调整二叉树即可。 add/offer方法的源代码：1234567891011121314151617181920212223242526272829303132333435363738394041//确实add调用了offerpublic boolean add(E e)&#123; return offer(e);&#125;public boolean offer(E e)&#123; if(e == null) throw new NullPointerException(); int i = size; if(i &gt;= queue.length) grow(i+1); size = i+1; if(i == 0) queue[0] = e; else siftUp(i, e); return true;&#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);&#125;private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125; 从上面的代码中也能看出：PriorityQueue中不能有空元素 下面是一个例子，包括了如何重写比较器(从大到小)：（比较器怎么记：默认情况是升序, 即o1&lt;o2&lt;o3&lt;o4，它返回的是o1-o2，也就是默认返回-1；如果要改成升序，只要返回o2-o1就行了。如果要降序，只需o1&lt;o2的时候返回1，或者直接返回o2-o1即可）1234567891011121314151617181920212223PriorityQueue pq = new PriorityQueue( new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; return o2-o1; &#125; &#125;);pq.offer(1);pq.offer(22);pq.offer(4);pq.offer(45);pq.offer(12);pq.offer(5);pq.offer(76);pq.offer(34);pq.offer(23);pq.offer(22);while(pq.peek()!=null)&#123; System.out.print(pq.poll() + " ");&#125; 参考：https://www.jianshu.com/p/4c7ad59a0489 Deque 也是接口，需要ArrayDeque/LinkedList来实现 Deque是一个双端队列，可以从头尾删除增加元素，所以可以用来实现栈的结构 常用方法： void addFirst(E e) 头插，下面的头插都是调用的这个函数，容量满了会抛出异常 boolean offerFirst(E e) 头插，调用addFirst，满了返回false，与前面优先级队列类似 void addLast(E e) 尾部插入，最基础的方法 boolean offerLast(E e) 尾部插入，调用addLast E getFirst() 获取栈顶元素，不删除 E peekFirst() 获取栈顶元素，不删除，队列为空的时候返回null E getLast() 类似 E peekLast() 类似 E removeFirst() 获取并删除队头元素 E pollFirst() 获取并删除队头元素，队列为空，返回null E removeLast() 获取并删除队尾元素 E pollLast() 获取并删除队尾元素，队列为空，返回null E pop() 弹出栈顶元素，调用的是removeFirst! void push(E e) 栈顶插入元素，调用的是addFirst boolean removeFirstOccurence(Object o) 删除第一次出现的o，通过调用remove(E e)方法实现， 不存在则不改变deque，返回false boolean removeLastOccurence(Object o) 删除最后一次出现的O Iterator descendingIterator() 返回双端队列的迭代器，逆向顺序迭代元素，元素顺序变成从尾到头 ArrayDeuqe 线程不安全 默认数组长度16 不允许存null值 循环数组实现 可以作为队列，也可以作为栈使用，但是同时只能当做一种，看你添加元素的时候用的是什么方法（确定头在哪里，尾在哪里） 性能比较好，作为栈时比stack好，作为队列时比LinkedList好 LinkedList 是通过链表实现，与之前的都不相同 可以使用之间QUEUE的所有方法，就是普通的队列 查找效率低，增加删除效率高]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>INTERVIEW</tag>
        <tag>FUNDAMENT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识]]></title>
    <url>%2F2020%2F07%2F03%2FFundament%2F</url>
    <content type="text"><![CDATA[WEB Header中的内容一般是给浏览器看的，body的内容才是真正给user看的 爬虫的作用是根据tag来找到不同的内容 用js-xlsx包读取本地excel文件时，通过XLSX.read方法会获得一个workbook对象，然后通过var jsondata = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]); 可以获得该表内容的”json对象”。json有两种数据结构：对象、数组。JSON 语法是 JavaScript 语法的子集,所以操作同JS一样。 //单一对象简单形式： var o={“name”:”bty”,”age”:11,”time”:”2009-08-20”}； //单一对象复杂形式： 12345678var o2 = &#123; "list":[ &#123;"password":"666","name":"bty"&#125;, &#123;"password":"422","name":"zsn"&#125;], "array":[ &#123;"password":"123","name":"bty"&#125;, &#123;"password":"452","name":"zsn"&#125;] &#125;; //数组简单形式： var jsonArr2 = [“Google”, “Runoob”, “Taobao”] //复杂形式： 12345var jsonArr2 = [ &#123;"name":"bty","age":11,"time":"2009-08-20"&#125;, &#123;"name":"zsn","age":10,"time":"2008-08-20"&#125; ]; 处理这些对象的方法并不复杂，例如修改第一个name的值：o2.list[0].name = &quot;sam&quot;; //修改对象属性的值 jsonArr2[0].name = &quot;sam&quot;; //修改数组元素的值 JAVA Queue的初始化, 要用链表：’Queue queue = new LinkedList&lt;&gt;(); String的indexOF方法： public int indexOf(int ch) //返回指定字符第一次出现的索引，没有则返回-1 public int indexOf(int ch, int fromIndex) //返回从指定位置开始，第一次出现字符的索引，没有返回-1 public int indexOf(String str) //查询指定子字符串substring第一次出现的索引，没找到返回-1 public int indexOf(String str, int fromIndex) //类似注意：用boolean String.contains(substr)也可以快速查找是否存在子串 String.replaceAll(String regex, String replacement), 其中第一个是需要替换的部分的正则表达式，即遇到符合这个的，替换 注意：比如我要去掉字符串中的a,e,i,o,u（即去掉元音字母），可以这么写s.replaceAll(“[aeiou]”, “”); Java正则表达式语法： &nbsp; . &nbsp;&nbsp; : 除\r, \n之外的任何字符 &nbsp; * &nbsp;&nbsp; ： 零次或多次之前的字符，比如 “[0-9]*” 表示0个或多个数字；“.*” 表示任意多个字符 &nbsp; + &nbsp;&nbsp; ： 一次或多次之前的字符，比如 “[0-9]+” 表示1个或多个数字； ? &nbsp;&nbsp;： 零次或一次之前的字符，比如 “ab?” 表示字符串“a”或字符串“ab”；”do(es)?”表示”do”或”does”； {n} &nbsp;&nbsp; : 正好匹配n次，比如“o{2}” 表示“oo” {n,} &nbsp;&nbsp;: 至少匹配n次，不难推断，{0,} 与前面的 * 的用法相同；{1,} 与前面的 + 用法相同 {n,m} &nbsp;&nbsp;: 至少匹配n次，至多匹配m次，不难推断 {0,1} 与前面的 ？ 用法相同 ？ &nbsp;&nbsp; ： 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o” x|y &nbsp;&nbsp;: 匹配 x 或 y。比如，“z|food” 匹配 “z” 或 “food” 。“(z|f)ood” 匹配 “zood” 或 “food”。 [xyz] &nbsp;&nbsp;: 字符集，匹配包含的任一字符，比如“[abcdef]” 可以匹配 abcdef任意一个字符。 [^xyz]&nbsp;&nbsp;: 反向字符集，匹配不是该集合中的字符， 比如“[^abcdef]” 可以匹配 任意一个不是abcdef的字符。 [A-Z] &nbsp;&nbsp;: 字符范围，从A到Z，比如“[a-z]”表示匹配从小写a到小写z的任意一个。 [^A-Z]&nbsp;&nbsp;: 反向字符范围，匹配不在这个字符范围的任意字符。 \b &nbsp;&nbsp; : 匹配一个字边界，即字与空格间的位置。例如，”er\b” 表示在边界的er, 也就是匹配”never”中的”er”，但不匹配”verb”中的”er”。 \B &nbsp;&nbsp;： 非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \d &nbsp;&nbsp;: 数字字符匹配。等效于 [0-9]。 \D &nbsp;&nbsp;: 非数字字符匹配。等效于 [^0-9]。 \f &nbsp;&nbsp;: 换页符匹配。等效于 \x0c 和 \cL。 \n &nbsp;&nbsp;: 换行符匹配。等效于 \x0a 和 \cJ。 \r &nbsp;&nbsp;: 匹配一个回车符。等效于 \x0d 和 \cM。 \s &nbsp;&nbsp;: 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。 \S &nbsp;&nbsp;: 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。 \t &nbsp;&nbsp;: 制表符匹配。与 \x09 和 \cI 等效。 \v &nbsp;&nbsp;: 垂直制表符匹配。与 \x0b 和 \cK 等效。 \w &nbsp;&nbsp;: 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \W &nbsp;&nbsp;: 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。(下面不常用) \xn : 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 \num : 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。 \n : 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 \nm : 标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。 \nml : 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \un : 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。 Java中的幂函数： double Math.pow(double a, double b) 返回的是a的b次方 Java中的对数函数： double Math.log(double x) 返回的是 ln x 或者 loge(x)；即以e为底的对数；Math.log10(double y)这个函数可以用来计算数字位数：如果需要计算数字y的位数，可以用(int)log10(y) + 1即可！ Java中快速转换进制：Integer.toString(number, base) 这个函数可以快速将number转换为base进制的数字字符串，只要再把它转换为数字即可 在一些递归的过程中，可能会存在大量的重复计算，这个时候，如果采用自底向上（bottom up）的方法，遍可以防止重复计算：在计算当前层数时，先判断上一层符不符合条件，然后用上一层的结果来进行这一层的计算或者比较，从而避免重复计算，当然有时需要创建一些新的数据结构，保存之前的状态。（之前可能是自顶向下，每次需要一个值就递归的去寻找计算，带来大量重复计算，造成资源浪费） 想要截取数组的一部分(比如截取数组的前10个，赋给一个新的数组)，可以用int[] Arrays.copyOfRange(int[] arr, int from, int to )函数，这样就返回了arr数组[FROM, to)的部分，包括from，不包括to 当一些函数的参数有比较器的时候，语法是这样的:12345678910111213141516171819Collections.sort(List&lt;T&gt; list, 比较器); =&gt; Collections.sort(List&lt;T&gt; list, new Comparator&lt;T&gt;()&#123; public int compare(T o1, T o2)&#123; //升序，o1 &lt; o2 的时候，返回-1 //降序，o1 &lt; o2 的时候，返回1 &#125;&#125;);//例子：为map中的value排降序(否则返回o1-o2)ArrayList&lt;Map.Entry&lt;Integer,Integer&gt;&gt; arr = new ArrayList&lt;&gt;( map.entrySet() );Collections.sort(arr, new Comparator&lt;Map.Entry&lt;Integer,Integer&gt;&gt;()&#123; public int compare( Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2 )&#123; return o2.getValue() - o1.getValue(); &#125; &#125;); 当拷贝一个Node对象时，是新建了一个引用，指向同一个对象：比如，在一个树中，本身有一个root对象，我再新建一个TreeNode temp = root，相当于有两个引用（root,temp）都指向这个root对象（并不是新建了一个root对象）：所以，Morris算法中的就不难理解了（为什么之后操作temp就可以让原来根节点的左孩子为空）：多引用指向同一对象的例子：每个方法都会有一个栈，一个类公用一个堆，上图是main方法的栈，存放对象的地址，如果有f1()方法，那么也会有一个f1的栈，不同栈中的引用可以指向同一个对象，即f1和main两个栈中存的地址可以相同，它们都是存在堆中对象的地址（和之前的temp,cur一样） 遇到需要降低时间复杂度的问题，可以多想一想二分查找之类的方法，可以把O(n)变为O(log n)。有的时候可能需要先排个序，但是其实这样是降低复杂度的。 String 中的startsWith方法：123456public boolean startsWith(String prefix, int offset)//或者public boolean startsWith(String prefix)//用于返回从offset开始（默认为0）的原字符串是否以prefix开头//比如有个字符串s，那么s.startsWith("abc") =&gt; 检查s是否以"abc"开头 如果某个算法的时间超标（time limited），检查是否有过多重复计算，如果有的话，加一个record数组，也许就可以解决问题了。（LEETCODE 322） Math.ceil()函数时对一个double型向上取整 Math.floor()函数时对一个double型向下取整 Math.round()函数时对一个double型四舍五入 SQL SQL中，判断一个值是不是null，用的是 is null语句，比如：12345select s.id, s.namefrom Students s left join Departments don d.id = s.department_idwhere d.name is null; SQL的distinct用法： distinct必须放在头部，不能 select name, distinct id from table 错！ 只能在select中使用，不能在 insert, delete, update 中用 distinct作用多个参数时，表示这些参数的组合是不重复的，比如（a,b） 和 （a,c）这就是符合要求的 不能和all 关键字一起用 不会过滤掉null，左移会返回null的值 如果想对单一属性进行去重，可以使用group by！ 也可以和集合函数一起用，比如count(distinct name) 把查询结果拼接成字符串的方法： group_concat()函数：语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )查询括号里的参数，默认用逗号分隔，如果要让这些参数按顺序，则要再加上order by, 正序直接order by 属性名，倒序order by 属性名 desc上面方法，如果结果太大，导致显示不全，可以在每次查询前：SET SESSION group_concat_max_len = 10240 这样，规定一个最大长度举例：显示相同名字的人的id号，这些id从大到小排序，下划线分隔：select name, group_concat(id order by id desc separator ‘_’) from table group by name concat(str1, str2)函数：直接拼接，没有分隔符，如果任意一个参数为Null，返回null concat_ws(separator, str1, str2, …)函数：第一个为分隔符，后面为要拼接的属性，比如 select concat_ws(‘,’ , id, name) 多个排序的用法： order by name desc, id asc=&gt; 这里就是先按照name降序，再按照id升序排序 将查询结果中的null赋值：ifnull( 含有null的属性, 要赋的值 )，这里的属性可以是集合函数，比如sum()，举例：(计算完的distance中可能有null值，因为它不存在rides表中，这时候把null变为0)1234567select u.name, ifnull(sum(r.distance), 0) as travelled_distancefrom users uleft join rides ron u.id = r.user_idgroup by r.user_idorder by travelled_distance desc, u.name asc round(想要规范化的数字，位数)函数： 4舍5入到小数点后几位，比如 ROUND(13.145, 2) =&gt; 结果就是13.15 case when end 用法：case [字段] when 表达式 then 显示数据 when 表达式 then 显示数据 else 显示数据 end需要注意的是end不能丢，并且这个语句相当于一个属性，比如：1234567891011121314151617select id, min(case when month = 'jan' then revenue else null end) as Jan_Revenue, =&gt; 意思是如果这个id对应的month里有jan，就输出相应的revenue sum(case when month = 'feb' then revenue else null end) as Feb_Revenue, =&gt; 虽然每个月的费用都只有一条，但是需要聚合函数配合group by，从null和一个数字中把数字选出来 sum(case when month = 'mar' then revenue else null end) as Mar_Revenue, =&gt; 所以min和sum这里的效果一样 sum(case when month = 'apr' then revenue else null end) as Apr_Revenue, =&gt; 具体题目见LC.1179 sum(case when month = 'may' then revenue else null end) as May_Revenue, sum(case when month = 'jun' then revenue else null end) as Jun_Revenue, sum(case when month = 'jul' then revenue else null end) as Jul_Revenue, sum(case when month = 'aug' then revenue else null end) as Aug_Revenue, sum(case when month = 'sep' then revenue else null end) as Sep_Revenue, sum(case when month = 'oct' then revenue else null end) as Oct_Revenue, sum(case when month = 'nov' then revenue else null end) as Nov_Revenue, sum(case when month = 'dec' then revenue else null end) as Dec_Revenuefrom departmentgroup by idorder by id 当需要条件计数，比如计算符合条件的行的个数，单独用count不好使，因为不管你符不符合条件，都会计算在内，除非这条记录是null，比如 count(a = b)，那么不管是否a=b，都会被计数，导致结果出错，这时，需要用到sum(条件)，（注意，这里的sum(条件表达式)表示，如果记录满足条件表达式就加1（而不是加其他值），所以只能统计满足条件的行数）或者用case when语句，比如：12345678910111213select sum(order_date = customer_pref_delivery_date)/count(*) as immediate_percentage from Delivery;# 这里的sum就是计算符合条件的记录数，如果用count(----)的话，得到的结果永远是1，因为它和count(*)效果一样# 这里还可以用下面这张case when 语句，效果是一样的SELECT sum(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END)/count(*) AS immediate_percentageFROM delivery# 注意：如果让 else 的时候 不是0 而是null，就可以用count来计数了，因为count只是不计算null而已SELECT count(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE null END)/count(*) AS immediate_percentageFROM delivery having语句的用法：where关键字中无法加入聚合函数，所以可以用having筛选分组后的各组数据 having语句如何不和group by一起使用，那么它和where的作用是一样的 having限制的是组，而where限制的是行，这也和上面一条相对应了 当有where， group by， having同时出现的时候，顺序是，先where查找符合条件的行，然后再用group by对数据进行分组，计算每个组的聚合函数的值，然后用having去掉不符合条件的组 having子句中出现的元素一定要在select中出现举个例子：123456SELECT Customer,SUM(OrderPrice) FROM OrdersWHERE Customer='Bush' OR Customer='Adams'GROUP BY CustomerHAVING SUM(OrderPrice)&gt;1500 abs()函数也有，取绝对值，用法：abs(数字) union操作可以连接两个select语句的结果，要注意的是，两个select结果必须拥有相同个数的列，相对应的列也必须是相同的数据类型，结果中的列名使用第一个select的列名 union 和 union all 的区别是union all不会去掉重复的行，所以会有重复。另外，union会进行默认规则的排序，union all则不会排序 exist用法：用于检查子查询是不是至少会返回一行数据，返回的结果是true/false，语法是where exists：(通俗理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。) 12345SELECT c.CustomerId, CompanyName FROM Customers cWHERE EXISTS( SELECT OrderID FROM Orders o WHERE o.CustomerID=c.CustomerID )；#这里显然，单看子查询，返回的是orderID，是无法获得我们需要的那2个属性的，所以不难推断出，子查询返回的是true/false limit 关键的用法：从一个偏移量开始，取之后的一部分数据：limit 3,10 =&gt; 取搜索结果第3行之后的10行（不包括第三行）；如果是 limit 2 默认是等于limit 0,2（取结果的前2行） sql中也有正则表达式regexp，当然like关键字可以模糊匹配，但是有时候需要用到正则表达式，语法为：123456789101112# where 属性 regexp '正则表达式'# ^ 匹配开头# $ 匹配结尾# . 任意字符# [] 字符集合，匹配括号内的任意字符# [^] 与上面相反，不包含括号内的字符# *, +, &#123;n&#125;, &#123;n,m&#125;, | 与java中的正则一样# 举例：匹配正确的邮箱：（以字母开头，只能包含字母，数字，下划线，点，dash，并且domain必须为leetcode.com）select *from tablewhere mail regexp '^[a-zA-Z][a-zA-Z0-9/./_/-]*@leetcode.com' 对于取排序后的前几条，limit有时候不够用，因为可能存在ties，这个时候，ms sql 中有个简单的方法，就是加top 1 with ties 关键字，top几根据需要来改变：1234SELECT TOP 5 WITH TIES EmpNumber,EmpName FROM Employee Order By EmpNumber DESC 在mysql中，也有个类似的方法，就是rank() 函数：（ rank() over (order by ~) as rnk, 然后在外循环中加一个where找到前几名即可 ）12345678SELECT project_id FROM ( SELECT project_id, COUNT(employee_id), RANK() OVER (ORDER BY COUNT(employee_id) DESC) AS rnk FROM project GROUP BY project_id) AS tempWHERE rnk = 1 algorithm Morris方法(可以用于前序 和 中序 遍历！) 这个方法是用来做树的遍历的（inorder traverse），当然也可以直接recursive，将之前的二叉树变成一个只有右孩子的树，且顺序时inorder的。 已知中序遍历是 左-根-右 的顺序，所以我们的目的是：将“根-右子树”放到左子树的最右边的节点上，直到所有节点都不含有左孩子，从而达到我们的目的。 所以该方法的流程是： 1. 以根节点root为起点，记为当前节点cur; 2. 如果cur不存在左孩子，很好，向下走，将cur节点指向它的右孩子，即cur = cur.right; 否则，找到左子树中最右边的节点（rightmost node），将该节点的右孩子指向当前节点cur，即 rightmost.right = cur，然后当前节点指向它的左孩子，即cur = cur.left; 3. 重复步骤2，直到cur节点为空 经过这样的步骤之后，我们就得到了一个按inorder排列的树，如果需要记录这个遍历，只需要在步骤2的第一个判断条件成立时记录当前节点的值即可。 代码(inorder遍历根节点为root的二叉树，并返回)： 1234567891011121314151617181920212223List&lt;Integer&gt; res = new ArrayList&lt;&gt;();TreeNode cur = root;while(cur != null)&#123; if(cur.left == null) &#123; res.add(cur.val); cur = cur.right; &#125; else &#123; TreeNode pre = cur.left; while(pre.right != null) &#123; pre = pre.right; &#125; pre.right = cur; TreeNode temp = cur; cur = cur.left; temp.left = null; &#125;&#125;return res;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>PYTHON</tag>
        <tag>INTERVIEW</tag>
        <tag>FUNDAMENT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记]]></title>
    <url>%2F2020%2F03%2F29%2FBooks%2F</url>
    <content type="text"><![CDATA[金字塔原理（The Pyramid Principle） 基本结构：结论先行，以上统下，归类分组，逻辑递进 先重要后次要，先总结后具体，先框架后细节，先结论后原因，先结果后过程，先论点后论据（类似议论文的结构） 听众最常出现的4个问题：是什么，为什么，怎么做，好不好 条理不清的原因：表达思想的顺序和读者的理解力之间的矛盾 “自上而下的表达，自下而上的思考” 自下而上的思考：就是一个不断归类，概括的过程，句子-&gt;段落-&gt;章节-&gt;文章 所有思想必须符合三个规则： 纵向：文章中任一层次的思想必须是下层思想的概括 横向：每组中的思想必须在同一逻辑范畴（检测方法是：能否用单一名字概括这组思想，比如“方法”，“问题”，“建议”） 横向：每组中的思想必须按照逻辑顺序组织 四种组织思想的逻辑顺序： 演绎顺序：大前提，小前提，结论 时间（步骤）顺序：第一，第二，第三 结构（空间）顺序：波士顿，纽约，华盛顿 程度（重要性）顺序：最重要，次要，最不重要 洞穴奇案 有5名探险家被困在一个洞穴里，并得知短时间内无法获救，水尽粮绝，饥寒交迫，于是他们提出，投骰子选出一个牺牲者，让其他四人吃掉这个人的血肉。在最后投掷前，A决定放弃这个方案，可是剩下四个人依然投了骰子，并且恰好选中了A作为牺牲者，而A是这个方案的最初发起人。剩下的四个人在吃掉A之后最终等来了救援，但是他们却被冠以杀人罪，执行了绞刑。那么这四个人到底有没有罪？ 注：概率没有问题，有人替A扔了骰子，并且A也没有提出异议 最初的观点：如果最终的判决是绞刑这4个人，那么这个方案无论如何都是毫无意义的，它将导致所有五个人的死亡。所以，假如这5名探险者当初只有这一个选项，那么遍不应该判处这4名获救者绞刑，因为这样判处的话就相当于毫无理由直接判处了这5个人绞刑。假如这5名探险者还有别的选择，那么A作为这个方案的最初提起者，相当于提出了一个5人全部牺牲的方案，那么A应该对这个决定付出最大的责任，而不是其他4个人。 1 法律规定：“任何人故意剥夺了他人的生命，都必须被判处死刑” 乔布斯传 硅谷最初在60年代末开始飞速发展，原因是军事承包，大量的资金涌入，半导体材料的大规模使用（军事需要），所以叫硅谷]]></content>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之路]]></title>
    <url>%2F2018%2F05%2F16%2FHow-to-get-this_3%2F</url>
    <content type="text"><![CDATA[优化next主题的一些操作1. 选择一个主题 theme的选择有很多，这里推荐一个主题网站 这里我选择的是使用人数最多的NEXT主题，参考的文档较多，便于入手 导入hexo主题方法： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 导入成功后，themes文件下会出现一个名为next文件夹，此时只是将next的主题包下载了下来，需要在站点配置文件中设置主题，也就是在站点配置文件中找到theme字段，将它的值改为你的主题名，这里我改为next 1theme: next 2. 两个主要配置文件 在根目录下的_config.yml文件，叫做站点配置文件 在主题目录下也会有一个_config.yml文件，叫做主题配置文件 3. 看下效果 更换主题后，一般要做如下三个操作 123hexo cleanhexo ghexo s 然后打开localhost:4000看看效果，是不是已经变成你的主题了~ 当然，主题中的很多插件都是默认关闭的，需要在之后的配置中根据自己的喜好设置，所以一开始看到的界面会很简单~ 4. 个性化域名 除了在本地演示，博客还可以通过你当时创建的仓库名来访问（你的用户名.github.io），不过每次完成更新后需要 1hexo d 来发布你的更新到服务器上，如果还是没有效果，可以这样： 123hexo cleanhexo ghexo d 来一遍完整的~ 如果觉得github的域名不好记，可以在一些域名网站购买一个喜欢的域名（.com域名最好），我买的域名是mambawang.com 买完域名后，需要与我们的博客网站绑定，先进入博客根目录的source文件中，创建一个名为CNAME的无后缀的文件，内容为你购买的域名 1mambawang.com 这里不需要加www，这样以后加不加www都可以访问你的网站 创建完CNAME文件之后，还要去你购买域名的网站的DNS的管理界面添加以下三条记录，过一会就可以直接输入你的域名访问博客了！ 不过，不知道是什么原因，使用godaddy自带的DNS时老是出问题，后来我把DNS转到DNSPOD上，就再也没出过问题了 记录类型 主机记录 记录值 解析线路 CNAME www 用户名.github.io default A @ 192.30.252.153 default A @ 192.30.252.154 default 5. 未完待续 听点儿歌吧~ 1.头像2.背景透明3.音乐4.网站图标5.超链接语法6.腾讯公益4047.菜单栏添加8.点击爆炸9.背景动画10.]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之路]]></title>
    <url>%2F2018%2F05%2F16%2FHow-to-get-this_2%2F</url>
    <content type="text"><![CDATA[完成基本配置后，怎么让我们的博客更好看？1. 选择一个主题 theme的选择有很多，这里推荐一个主题网站 这里我选择的是使用人数最多的NEXT主题，参考的文档较多，便于入手 导入hexo主题方法： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 导入成功后，themes文件下会出现一个名为next文件夹，此时只是将next的主题包下载了下来，需要在站点配置文件中设置主题，也就是在站点配置文件中找到theme字段，将它的值改为你的主题名，这里我改为next 1theme: next 2. 两个主要配置文件 在根目录下的_config.yml文件，叫做站点配置文件 在主题目录下也会有一个_config.yml文件，叫做主题配置文件 3. 看下效果 更换主题后，一般要做如下三个操作 123hexo cleanhexo ghexo s 然后打开localhost:4000看看效果，是不是已经变成你的主题了~ 当然，主题中的很多插件都是默认关闭的，需要在之后的配置中根据自己的喜好设置，所以一开始看到的界面会很简单~ 4. 个性化域名 除了在本地演示，博客还可以通过你当时创建的仓库名来访问（你的用户名.github.io），不过每次完成更新后需要 1hexo d 来发布你的更新到服务器上，如果还是没有效果，可以这样： 123hexo cleanhexo ghexo d 来一遍完整的~ 如果觉得github的域名不好记，可以在一些域名网站购买一个喜欢的域名（.com域名最好），我买的域名是mambawang.com 买完域名后，需要与我们的博客网站绑定，先进入博客根目录的source文件中，创建一个名为CNAME的无后缀的文件，内容为你购买的域名 1mambawang.com 这里不需要加www，这样以后加不加www都可以访问你的网站 创建完CNAME文件之后，还要去你购买域名的网站的DNS的管理界面添加以下三条记录，过一会就可以直接输入你的域名访问博客了！ 不过，不知道是什么原因，使用godaddy自带的DNS时老是出问题，后来我把DNS转到DNSPOD上，就再也没出过问题了 记录类型 主机记录 记录值 解析线路 CNAME www 用户名.github.io default A @ 192.30.252.153 default A @ 192.30.252.154 default 5. 未完待续 听点儿歌吧~]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之路]]></title>
    <url>%2F2018%2F05%2F08%2FHow-to-get-this_1%2F</url>
    <content type="text"><![CDATA[1. 基本环境 &amp; 配置（具体如何配置环境请自行google） 检查Node.js &amp; npm 环境 检查Git环境 2. 在Github上创建代码库（用于上传blog代码） 在github中创建一个新的repository，这个仓库的名字要用yourname.github.io这个形式 例如: 你的github用户名叫ABC，那么仓库名必须为ABC.github.io，其他参数都默认即可 3. 配置Hexo 在你的PC上创建一个新文件夹，今后的所有操作都只在这个文件夹中进行（网站的所有文件都在这个文件夹中） 打开这个空文件夹，空白处 shift + 鼠标右键，输入 1hexo init 进行初始化工作，要注意的是初始化只有在空文件夹下才起作用 继续输入 1npm install hexo-cli -g 会出现一些warn，不用管它们 继续输入 1npm install hexo --save 到这里hexo的环境应该已经配置好了，输入 1hexo -v 来检查hexo环境，如果出现一堆版本信息，则说明配置成功 4. 初始化Hexo 接着上面输入 1hexo init 不过，如果这时你的文件夹不是空的就不用输入这一行了 继续输入 1npm install 完成初始化 5. 初步体验Hexo 继续输入 1hexo -g 最后输入 1hexo -s 浏览器中输入localhost:4000，可以看到一个初步的Hexo页面，格式都是Hexo为我们自动生成的，可以修改 6. 未完待续 听点儿歌吧~]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文章示例]]></title>
    <url>%2F2018%2F05%2F07%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Dillinger Dillinger is a cloud-enabled, mobile-ready, offline-storage, AngularJS powered HTML5 Markdown editor. Type some Markdown on the left See HTML in the right Magic New Features! Import a HTML file and watch it magically convert to Markdown Drag and drop images (requires your Dropbox account be linked) You can also: Import and save files from GitHub, Dropbox, Google Drive and One Drive Drag and drop markdown and HTML files into Dillinger Export documents as Markdown, HTML and PDF Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As John Gruber writes on the Markdown site The overriding design goal for Markdown’sformatting syntax is to make it as readableas possible. The idea is that aMarkdown-formatted document should bepublishable as-is, as plain text, withoutlooking like it’s been marked up with tagsor formatting instructions. This text you see here is actually written in Markdown! To get a feel for Markdown’s syntax, type some text into the left window and watch the results in the right. TechDillinger uses a number of open source projects to work properly: AngularJS - HTML enhanced for web apps! Ace Editor - awesome web-based text editor markdown-it - Markdown parser done right. Fast and easy to extend. Twitter Bootstrap - great UI boilerplate for modern web apps node.js - evented I/O for the backend Express - fast node.js network app framework @tjholowaychuk Gulp - the streaming build system Breakdance - HTML to Markdown converter jQuery - duh And of course Dillinger itself is open source with a public repository on GitHub. InstallationDillinger requires Node.js v4+ to run. Install the dependencies and devDependencies and start the server. 123$ cd dillinger$ npm install -d$ node app For production environments… 12$ npm install --production$ NODE_ENV=production node app PluginsDillinger is currently extended with the following plugins. Instructions on how to use them in your own application are linked below. Plugin README Dropbox plugins/dropbox/README.md Github plugins/github/README.md Google Drive plugins/googledrive/README.md OneDrive plugins/onedrive/README.md Medium plugins/medium/README.md Google Analytics plugins/googleanalytics/README.md DevelopmentWant to contribute? Great! Dillinger uses Gulp + Webpack for fast developing.Make a change in your file and instantanously see your updates! Open your favorite Terminal and run these commands. First Tab:1$ node app Second Tab:1$ gulp watch (optional) Third:1$ karma test Building for sourceFor production release:1$ gulp build --prod Generating pre-built zip archives for distribution:1$ gulp build dist --prod DockerDillinger is very easy to install and deploy in a Docker container. By default, the Docker will expose port 8080, so change this within the Dockerfile if necessary. When ready, simply use the Dockerfile to build the image. 12cd dillingerdocker build -t joemccann/dillinger:$&#123;package.json.version&#125; This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out ${package.json.version} with the actual version of Dillinger. Once done, run the Docker image and map the port to whatever you wish on your host. In this example, we simply map port 8000 of the host to port 8080 of the Docker (or whatever port was exposed in the Dockerfile): 1docker run -d -p 8000:8080 --restart="always" &lt;youruser&gt;/dillinger:$&#123;package.json.version&#125; Verify the deployment by navigating to your server address in your preferred browser. 1127.0.0.1:8000 Kubernetes + Google CloudSee KUBERNETES.md Todos Write MORE Tests Add Night Mode LicenseMIT Free Software, Hell Yeah!]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Daily]]></title>
    <url>%2F2018%2F04%2F03%2FDaily%2F</url>
    <content type="text"><![CDATA[水深火热： 前一天阿开不关煤气，关键是他人还在客厅，都没闻到…后一天赵梓良不关火，我又在自己屋里闻到糊味出来检查一下…第三天又没关煤气…我能活到现在真是个奇迹。 一个idea 相处一个idea，符合自己的兴趣，有意义，有趣，选好一个目标：篮球，留学生，疫情idea1 疫情期间航线查询 2020-05-10 读乔布斯传 突然发现应该少看知乎，至少在自己能够独立思考之前，不然总是会在遇到问题时第一时间去知乎，而放弃了自己的思考 看到有人把乔布斯的病和他的素食主义关联到一起，想到了之前上过的一门课，因果推论，虽然很多时候因和果存在一定的时间关系，但并不一定A发生在B之前，A就是B的原因 有可能C也发生在B之前，C才是B的真正原因，而A和B实际上没什么关系对于因果是否存在时间关系，举个例子，总的来看，高学历可以获得更高的工资，但同时，也意味着要获得高工资，你需要更高的学历，从而形成了一种双向的因果。 聪明，智慧，迷茫，孤僻，固执，嬉皮士，素食，辍学，印度，禅宗，修行， 可以编写一个手册，记录我目前的状态到最终找到工作的一个过程。idea的来源是github上的一个外国小哥自学8个月进amazon的经历 可以把知识点变成知识卡，做成答题游戏（记忆卡，flash card） 一万小时定律：人们眼中的天才并非是人们所见的那样，天资超凡，一个人在任何一个领域从平凡变成非凡都要经历10000小时的持续努力（一万小时是从平凡到非凡的必须的锤炼）。要成为某个领域的专家，需要10000小时，按比例计算就是如果每天8小时的学习，一周工作5天，则需要至少5年。 2020-07-10 来美国3年了，终于还是到了要做这个决定的时候。三年时间，我其实并没有变化多少，永远把事情拖到最后一天，永远做不到坚持，永远盲目自信。我还是不爱读书，还是三分钟热度，还是知错不改，还是假装自己很优秀。我以为 不去做，就不会做错，不去尝试就不会被拒绝。永远被动，以为机会可以自己落到你的头上。可人生并不是小说，我也不是那个主角，你不争取，你想要的又怎么会自己找上门来。已经不是只要会考试，你是好学生就足够的年纪了。高中，我努力一下，就可以考试竞赛两开花，好像只要我努力，好事都会自己找上门来，全是夸奖，一切都是那么美好。还没高考，就感觉自己已经被录取了，南大不在话下，清北也不是没有可能。粉饰太平罢了，眼高手低一直是我最大的问题。看着其他同学拿着清北复交的通知书，我第一次受到了打击，但我还是安慰自己，没关系，这不代表什么，别人也这么和我说，没事，没关系。进入大学，我发现那里也有很多，好像“和我之前同样优秀”的人，他们很努力，也很聪明，我常常这么安慰自己，我不是一个人，我只是失误了一次罢了。我开始不认真听课，不写作业，因为我觉得我可以。然后我挂科了。还是我自以为最拿手的数学。我开始认真，我又回到了前几名，那种盲目自信又回来了。时代变了，大家都在忙着实习，忙着社团，忙着社交，而我，忙着沾沾自喜。回过头来，除了并不是那么出色的成绩单，我什么也没有留下。班主任甚至连我的名字都读不顺扣，我还总抱怨，我现在也是前几名了，你怎么还是记不住我。幼稚。鸡汤看多了，总是期待别人能看到什么而不是自己去争取什么。 来美国之后，第一任舍友复旦，第二个舍友又是复旦，同校还有清华学长，我又有安慰自己的理由了，我也不是那么差吗，毕竟他们也才来这里。一年，两年，我还是那样，闷头学习，按时作业，两耳不闻，两年的履历又只是一张成绩单，还没有拿到满绩。假期永远是用来玩的，作业永远都能完成，永远都拖到最后一天。说自己喜欢篮球，觉得自己打的不错，但我甚至连学校的篮球队都没有加入，我都不知道什么时候去报名，我只会窝在家里打2k。]]></content>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log]]></title>
    <url>%2F2018%2F03%2F27%2FLog%2F</url>
    <content type="text"><![CDATA[不能上传文章问题，解决办法：更新git版本，更改配置文件deploy中的repo地址 还有小问题是每次上传都要输密码，解决办法： 加入左下角的动画人物步骤：获取live2d npm install –save hexo-helper-live2d ; 导入所需图形 npm install live2d-widget-model-shizuku ; 在站点配置文件下添加： live2d的代码 更改鼠标样式尝试了一上午， 失败 想写一个网页计数器，记录学习时间，看到一个不错的，搞了半天最后发现它其实用的是一个动画效果来展示时间，放弃 setTimeout是JavaScript中的函数，用于延时执行某个函数，参数第一个为函数名或代码段，第二个为延时（ms） hexo本来就是静态的博客，所以把所有数据都存在本地即可，没必要浪费时间在这上 回忆和BeaconFire Hr聊天: 前端本身就是一个不断迭代的过程，5年之前，根本没人用react，也没人知道什么是react，五年后的现在，它就变成了最流行的js库了，做CS这一行，就是得不断学习，不断更新技术栈，不然很快就会被淘汰]]></content>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
</search>
