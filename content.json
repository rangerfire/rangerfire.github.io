{"meta":{"title":"Sicong·Wang·Blog","subtitle":"Valar Dohaeris","description":"Valar Morghulis","author":"Sicong Wang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"God Bless Programmer","slug":"NeverBug","date":"2028-05-09T00:02:11.000Z","updated":"2020-03-27T17:14:27.170Z","comments":true,"path":"2028/05/08/NeverBug/","link":"","permalink":"http://yoursite.com/2028/05/08/NeverBug/","excerpt":"","text":"_oo0oo_ _oo0oo_ o8888888o o8888888o 88&quot; . &quot;88 88&quot; . &quot;88 (| -_- |) (| -_- |) 0\\ = /0 0\\ = /0 ___/`---&apos;\\___ ___/`---&apos;\\___ .&apos; \\\\| |// &apos;. .&apos; \\\\| |// &apos;. / \\\\||| : |||// \\ / \\\\||| : |||// \\ / _||||| -:- |||||- \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | | \\\\\\ - /// | | | \\_| &apos;&apos;\\---/&apos;&apos; |_/ | | \\_| &apos;&apos;\\---/&apos;&apos; |_/ | \\ .-\\__ &apos;-&apos; ___/-. / \\ .-\\__ &apos;-&apos; ___/-. / ___&apos;. .&apos; /--.--\\ `. .&apos;___ ___&apos;. .&apos; /--.--\\ `. .&apos;___ .&quot;&quot; &apos;&lt; `.___\\_&lt;|&gt;_/___.&apos; &gt;&apos; &quot;&quot;. .&quot;&quot; &apos;&lt; `.___\\_&lt;|&gt;_/___.&apos; &gt;&apos; &quot;&quot;. | | : `- \\`.;`\\ _ /`;.`/ - ` : | | | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `_. \\_ __\\ /__ _/ .-` / / \\ \\ `_. \\_ __\\ /__ _/ .-` / / =====`-.____`.___ \\_____/___.-`___.-&apos;===== =====`-.____`.___ \\_____/___.-`___.-&apos;===== `=---=&apos; `=---=&apos; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 写字楼里写字间，写字间里程序员； 程序人员写程序，又拿程序换酒钱。 酒醒只在网上坐，酒醉还来网下眠； 酒醉酒醒日复日，网上网下年复年。 但愿老死电脑间，不愿鞠躬老板前； 奔驰宝马贵者趣，公交自行程序员。 别人笑我忒疯癫，我笑自己命太贱； 不见满街漂亮妹，哪个归得程序员？","categories":[],"tags":[]},{"title":"多线程详解","slug":"Java_Threads","date":"2020-07-05T19:39:11.000Z","updated":"2020-07-06T03:29:51.121Z","comments":true,"path":"2020/07/05/Java_Threads/","link":"","permalink":"http://yoursite.com/2020/07/05/Java_Threads/","excerpt":"待整合，有点乱","text":"待整合，有点乱 wait()/notify()/notifyAll() 这三个方法都是Object对象的，那就是每个对象都有的。（但是一般在多线程中才会用到） 为什么要用到这三个方法：比如，有2个线程，线程A是做报数操作，从1开始报数，直到100，线程B是当报数到100的时候输出“完成”。如果我们在线程B中用while（i==100）这种语句，那么CPU会一直在线程B中做判断操作，浪费资源，这时候我们就需要wait操作，如果不满足条件，先等着，等到有变化的时候，再让别的程序去叫醒它，也就是notify它 wait()方法：使当前执行代码的线程开始等待，将当前线程放入“预执行队列”，并且在wait()所在的代码处停止执行，知道接到通知或被中断。注意，在调用wait()之前，线程必须获得该对象的锁，因此只能在同步代码块/同步方法中调用wait()。wait()方法可以使调用该线程的方法释放共享资源的锁，从运行态变为等待态！ notify()方法：如果有多个线程等待，那么线程规划器随机挑选出一个wait的线程，对其发出通知notify()，并使它等待获取该对象的对象锁。注意”等待获取该对象的对象锁”，这意味着，即使收到了通知，wait的线程也不会马上获取对象锁，必须等待notify()方法的线程释放锁才可以。notify()方法将唤醒的线程从等待态变为 可运行状态。和wait()一样，notify()也要在同步方法/同步代码块中调用。 notifyAll()方法： 不是随机挑一个wait的线程，而是唤醒所有线程。 关于释放锁，wait方法会释放锁，而notify方法不释放锁，需要等到notify的线程运行完之后，才释放对象锁 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class MyThread1 extends Thread&#123; private Object lock; public MyThread1(Object lock) &#123; this.lock = lock; &#125; //override run() public void run() &#123; try &#123; synchronized(lock) &#123; System.out.println(\"start wait: \" + System.currentTimeMillis() ); lock.wait(); System.out.println(\"end wait: \" + System.currentTimeMillis() ); &#125; &#125;catch(Exception e) &#123; System.out.println(Thread.currentThread().getName() + \" has exception\"); &#125; &#125;&#125;class MyThread2 extends Thread&#123; private Object lock; public MyThread2(Object lock) &#123; this.lock = lock; &#125; public void run() &#123; try &#123; synchronized (lock) &#123; System.out.println(\"start notify: \" + System.currentTimeMillis() ); lock.notify(); System.out.println(\"end notify: \" + System.currentTimeMillis() ); &#125; &#125;catch(Exception e) &#123; System.out.println(Thread.currentThread().getName() + \" has exception\"); &#125; &#125;&#125;//main函数:public static void main(String[] args) throws InterruptedException &#123; // TODO Auto-generated method stub //simple wait/notify example Object lock = new Object(); MyThread1 mt1 = new MyThread1(lock); MyThread2 mt2 = new MyThread2(lock); mt1.start(); Thread.sleep(3000); //否则看不出效果 mt2.start(); &#125; Thread.interrupt()方法: 简要介绍一下（之后详解） 该方法不是直接中断该线程，而是给这个线程一个提醒，线程内部可以捕获InterruptedException异常来应对中断，比如return或者改变共享变量的值等方法使其退出 它不会中断一个正在运行的线程（比如在wait()的线程是可以interrupt的） synchronized在获锁的过程中是不能被中断的，也就是说，产生了死锁，则不可能被中断 如果wait()方法和notify()/notifyAll()方法不在同步方法/同步代码块中被调用，那么虚拟机会抛出java.lang.IllegalMonitorStateException，注意一下。 其他","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"http://yoursite.com/tags/INTERVIEW/"},{"name":"FUNDAMENT","slug":"FUNDAMENT","permalink":"http://yoursite.com/tags/FUNDAMENT/"},{"name":"Threads","slug":"Threads","permalink":"http://yoursite.com/tags/Threads/"}]},{"title":"Queue详解","slug":"Java_Queue","date":"2020-07-03T15:39:11.000Z","updated":"2020-07-07T00:59:52.879Z","comments":true,"path":"2020/07/03/Java_Queue/","link":"","permalink":"http://yoursite.com/2020/07/03/Java_Queue/","excerpt":"简介 Queue是一种数据结构，与stack不同，是实现先入先出功能的线性表。 常用方法： boolean add(E e): 队尾添加一个元素，如果队列满了，会抛出异常 boolean offer(E e): 队尾添加一个元素，队列满了，返回false，不会抛出异常 E remove(): 队头删除一个元素，并返回该元素的值，当队列为空的时候，抛出异常 E poll(): 队头删除一个元素，并返回该元素的值，当队列为空的时候，不会抛出异常，会返回一个null","text":"简介 Queue是一种数据结构，与stack不同，是实现先入先出功能的线性表。 常用方法： boolean add(E e): 队尾添加一个元素，如果队列满了，会抛出异常 boolean offer(E e): 队尾添加一个元素，队列满了，返回false，不会抛出异常 E remove(): 队头删除一个元素，并返回该元素的值，当队列为空的时候，抛出异常 E poll(): 队头删除一个元素，并返回该元素的值，当队列为空的时候，不会抛出异常，会返回一个null E element(): 返回队列头部的元素，不删除它，如果队列为空，抛出异常 E peek(): 返回队列头部的元素，不删除它，如果队列为空，返回null，不会抛出异常 E remove(E e): 删除值为e的最先出现的那个元素 Queue是一个接口，继承自Collection接口，需要被实现，PriorityQueue/ArrayDeque/LinkedList，都可以实现Queue接口，Dequeue是Queue的子接口，需要ArrayDeque/LinkedList实现 LinkedList不可以设置queue的容量，而ArrayDeque(int numElements)，PriorityQueue(int initialCapacity)是可以实现预设容量的 PriorityQueue 优先级队列在取出元素的时候，不是按照进入的顺序取的，它是按照大小来取的，默认从小到大排列，一般情况下需要重新写一下比较器 comparator PriorityQueue，逻辑上是用堆实现的（完全二叉树），默认的时候是最小堆，物理上使用的是动态数组实现的（ArrayList）,通过按照指定方式出队，来完成有序，也就是“优先级”的作用，所以，如果直接调用toString()方法，得到的结果并不是有序的，只有一个一个poll()出来，才是有序的！ 对于上述的toString()方法，结果为什么不是有序的，比如：offer()的顺序时5，-1, 3, 7; 那么由于它是按照最小堆的方法构成的，所以它是按照最小堆的结构去不断插入并调整行加的元素，而物理上它是数组的形式，所以它的过程是：[5] -&gt; [-1, 5] -&gt; [-1, 5, 3] -&gt; [-1, 5, 3, 7]；这就是当前这个queue的存放顺序，这也是符合最小堆不是完全有序的这个特性的，所以你此时调用toString()方法，它的结果是[-1, 5, 3, 7]，并不是我们想要的结果； 而当我们一个一个poll出来的时候，每次操作都会弹出堆顶的元素，然后再调整堆使它继续满足最小堆，这时，我们就可以得到正确顺序的结果！ PriorityQueue的默认容量是11，之后会根据情况选择扩容至2倍还是1.5倍 PriorityQueue内部主要属性：123456private static final int DEFAULT_INITIAL_CAPACITY = 11; //默认用于存储节点信息的数组的大小transient Object[] queue; //用于存储节点信息的数组private int size = 0; //数组中实际存放元素的个数private final Comparator&lt;? super E&gt; comparator; //Comparator比较器transient int modCount = 0; //用于记录修改次数的变量 PriorityQueue的构造器：12345678910111213141516public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null);&#125;public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null);&#125;public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator);&#125;public PriorityQueue(int initialCapacity,Comparator&lt;? super E&gt; comparator) &#123; if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator;&#125; 实际上前面三种构造器，最后都会调用第四个构造器。 对于PriorityQueue中的增删改查操作，它们在内部就是最大堆或者最小堆的增删改查操作，（注意add方法内部也调用了offer方法），添加上面已经说过，删除一个节点的步骤为先判断是不是尾节点，是就直接删除，否则用记录最后一个节点的值，用它覆盖要删除的节点的值，然后先向下检查并修改使它们满足堆结构，再向上修改，使它们满足最小最大堆要求即可。出队则相当于删除头节点，依次向下调整二叉树即可。 add/offer方法的源代码：1234567891011121314151617181920212223242526272829303132333435363738394041//确实add调用了offerpublic boolean add(E e)&#123; return offer(e);&#125;public boolean offer(E e)&#123; if(e == null) throw new NullPointerException(); int i = size; if(i &gt;= queue.length) grow(i+1); size = i+1; if(i == 0) queue[0] = e; else siftUp(i, e); return true;&#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);&#125;private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125; 从上面的代码中也能看出：PriorityQueue中不能有空元素 下面是一个例子，包括了如何重写比较器(从大到小)：（比较器怎么记：默认情况是升序，返回的是o1-o2，即o1 o1-o2 o1&lt;o2的时候返回-1；如果要降序，只需o1&lt;o2的时候返回1，或者直接返回o2-o1即可）1234567891011121314151617181920212223PriorityQueue pq = new PriorityQueue( new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; return o2-o1; &#125; &#125;);pq.offer(1);pq.offer(22);pq.offer(4);pq.offer(45);pq.offer(12);pq.offer(5);pq.offer(76);pq.offer(34);pq.offer(23);pq.offer(22);while(pq.peek()!=null)&#123; System.out.print(pq.poll() + \" \");&#125; 参考：https://www.jianshu.com/p/4c7ad59a0489 Deque 也是接口，需要ArrayDeque/LinkedList来实现 Deque是一个双端队列，可以从头尾删除增加元素，所以可以用来实现栈的结构 常用方法： void addFirst(E e) 头插，下面的头插都是调用的这个函数，容量满了会抛出异常 boolean offerFirst(E e) 头插，调用addFirst，满了返回false，与前面优先级队列类似 void addLast(E e) 尾部插入，最基础的方法 boolean offerLast(E e) 尾部插入，调用addLast E getFirst() 获取栈顶元素，不删除 E peekFirst() 获取栈顶元素，不删除，队列为空的时候返回null E getLast() 类似 E peekLast() 类似 E removeFirst() 获取并删除队头元素 E pollFirst() 获取并删除队头元素，队列为空，返回null E removeLast() 获取并删除队尾元素 E pollLast() 获取并删除队尾元素，队列为空，返回null E pop() 弹出栈顶元素，调用的是removeFirst! void push(E e) 栈顶插入元素，调用的是addFirst boolean removeFirstOccurence(Object o) 删除第一次出现的o，通过调用remove(E e)方法实现， 不存在则不改变deque，返回false boolean removeLastOccurence(Object o) 删除最后一次出现的O Iterator descendingIterator() 返回双端队列的迭代器，逆向顺序迭代元素，元素顺序变成从尾到头 ArrayDeuqe 线程不安全 默认数组长度16 不允许存null值 循环数组实现 可以作为队列，也可以作为栈使用，但是同时只能当做一种，看你添加元素的时候用的是什么方法（确定头在哪里，尾在哪里） 性能比较好，作为栈时比stack好，作为队列时比LinkedList好 LinkedList 是通过链表实现，与之前的都不相同 可以使用之间QUEUE的所有方法，就是普通的队列 查找效率低，增加删除效率高","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"http://yoursite.com/tags/INTERVIEW/"},{"name":"FUNDAMENT","slug":"FUNDAMENT","permalink":"http://yoursite.com/tags/FUNDAMENT/"}]},{"title":"基础知识","slug":"Fundament","date":"2020-07-03T15:29:11.000Z","updated":"2020-07-07T02:52:40.099Z","comments":true,"path":"2020/07/03/Fundament/","link":"","permalink":"http://yoursite.com/2020/07/03/Fundament/","excerpt":"","text":"WEB Header中的内容一般是给浏览器看的，body的内容才是真正给user看的 爬虫的作用是根据tag来找到不同的内容 用js-xlsx包读取本地excel文件时，通过XLSX.read方法会获得一个workbook对象，然后通过var jsondata = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]); 可以获得该表内容的”json对象”。json有两种数据结构：对象、数组。JSON 语法是 JavaScript 语法的子集,所以操作同JS一样。 //单一对象简单形式： var o={“name”:”bty”,”age”:11,”time”:”2009-08-20”}； //单一对象复杂形式： var o2 = { &quot;list&quot;:[ {&quot;password&quot;:&quot;666&quot;,&quot;name&quot;:&quot;bty&quot;}, {&quot;password&quot;:&quot;422&quot;,&quot;name&quot;:&quot;zsn&quot;}], &quot;array&quot;:[ {&quot;password&quot;:&quot;123&quot;,&quot;name&quot;:&quot;bty&quot;}, {&quot;password&quot;:&quot;452&quot;,&quot;name&quot;:&quot;zsn&quot;}] }; //数组简单形式： var jsonArr2 = [“Google”, “Runoob”, “Taobao”] //复杂形式： var jsonArr2 = [ {&quot;name&quot;:&quot;bty&quot;,&quot;age&quot;:11,&quot;time&quot;:&quot;2009-08-20&quot;}, {&quot;name&quot;:&quot;zsn&quot;,&quot;age&quot;:10,&quot;time&quot;:&quot;2008-08-20&quot;} ]; 处理这些对象的方法并不复杂，例如修改第一个name的值： o2.list[0].name = &quot;sam&quot;; //修改对象属性的值 jsonArr2[0].name = &quot;sam&quot;; //修改数组元素的值 JAVA Queue的初始化, 要用链表：’Queue queue = LinkedList&lt;&gt;(); String的indexOF方法： public int indexOf(int ch) //返回指定字符第一次出现的索引，没有则返回-1 public int indexOf(int ch, int fromIndex) //返回从指定位置开始，第一次出现字符的索引，没有返回-1 public int indexOf(String str) //查询指定子字符串substring第一次出现的索引，没找到返回-1 public int indexOf(String str, int fromIndex) //类似注意：用boolean String.contains(substr)也可以快速查找是否存在子串 String.replaceAll(String regex, String replacement), 其中第一个是需要替换的部分的正则表达式，即遇到符合这个的，替换 注意：比如我要去掉字符串中的a,e,i,o,u（即去掉元音字母），可以这么写s.replaceAll(“[aeiou]”, “”); Java正则表达式语法： &nbsp; . &nbsp;&nbsp; : 除\\r, \\n之外的任何字符 &nbsp; * &nbsp;&nbsp; ： 零次或多次之前的字符，比如 “[0-9]*” 表示0个或多个数字；“.*” 表示任意多个字符 &nbsp; + &nbsp;&nbsp; ： 一次或多次之前的字符，比如 “[0-9]+” 表示1个或多个数字； ? &nbsp;&nbsp;： 零次或一次之前的字符，比如 “ab?” 表示字符串“a”或字符串“ab”；”do(es)?”表示”do”或”does”； {n} &nbsp;&nbsp; : 正好匹配n次，比如“o{2}” 表示“oo” {n,} &nbsp;&nbsp;: 至少匹配n次，不难推断，{0,} 与前面的 * 的用法相同；{1,} 与前面的 + 用法相同 {n,m} &nbsp;&nbsp;: 至少匹配n次，至多匹配m次，不难推断 {0,1} 与前面的 ？ 用法相同 ？ &nbsp;&nbsp; ： 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o” x|y &nbsp;&nbsp;: 匹配 x 或 y。比如，“z|food” 匹配 “z” 或 “food” 。“(z|f)ood” 匹配 “zood” 或 “food”。 [xyz] &nbsp;&nbsp;: 字符集，匹配包含的任一字符，比如“[abcdef]” 可以匹配 abcdef任意一个字符。 [^xyz]&nbsp;&nbsp;: 反向字符集，匹配不是该集合中的字符， 比如“[^abcdef]” 可以匹配 任意一个不是abcdef的字符。 [A-Z] &nbsp;&nbsp;: 字符范围，从A到Z，比如“[a-z]”表示匹配从小写a到小写z的任意一个。 [^A-Z]&nbsp;&nbsp;: 反向字符范围，匹配不在这个字符范围的任意字符。 \\b &nbsp;&nbsp; : 匹配一个字边界，即字与空格间的位置。例如，”er\\b” 表示在边界的er, 也就是匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\B &nbsp;&nbsp;： 非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \\d &nbsp;&nbsp;: 数字字符匹配。等效于 [0-9]。 \\D &nbsp;&nbsp;: 非数字字符匹配。等效于 [^0-9]。 \\f &nbsp;&nbsp;: 换页符匹配。等效于 \\x0c 和 \\cL。 \\n &nbsp;&nbsp;: 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r &nbsp;&nbsp;: 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s &nbsp;&nbsp;: 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。 \\S &nbsp;&nbsp;: 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。 \\t &nbsp;&nbsp;: 制表符匹配。与 \\x09 和 \\cI 等效。 \\v &nbsp;&nbsp;: 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w &nbsp;&nbsp;: 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \\W &nbsp;&nbsp;: 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。(下面不常用) \\xn : 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 \\num : 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。 \\n : 标识一个八进制转义码或反向引用。如果 \\n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 \\nm : 标识一个八进制转义码或反向引用。如果 \\nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \\nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \\nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。 \\nml : 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un : 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 Java中的幂函数： Math.pow(double a, double b) 返回的是a的b次方 Java中的对数函数： double Math.log(double x) 返回的是 ln x 或者 loge(x)；即以e为底的对数；Math.log10(double y)这个函数可以用来计算数字位数：如果需要计算数字y的位数，可以用(int)log10(y) + 1即可！ Java中快速转换进制：Integer.toString(number, base) 这个函数可以快速将number转换为base进制的数字字符串，只要再把它转换为数字即可 SQL SQL中，判断一个值是不是null，用的是 is null语句，比如：12345select s.id, s.namefrom Students s left join Departments don d.id = s.department_idwhere d.name is null; SQL的distinct用法： distinct必须放在头部，不能 select name, distinct id from table 错！ 只能在select中使用，不能在 insert, delete, update 中用 distinct作用多个参数时，表示这些参数的组合是不重复的，比如（a,b） 和 （a,c）这就是符合要求的 不能和all 关键字一起用 不会过滤掉null，左移会返回null的值 如果想对单一属性进行去重，可以使用group by！ 也可以和集合函数一起用，比如count(distinct name) 把查询结果拼接成字符串的方法： group_concat()函数：语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )查询括号里的参数，默认用逗号分隔，如果要让这些参数按顺序，则要再加上order by, 正序直接order by 属性名，倒序order by 属性名 desc上面方法，如果结果太大，导致显示不全，可以在每次查询前：SET SESSION group_concat_max_len = 10240 这样，规定一个最大长度举例：显示相同名字的人的id号，这些id从大到小排序，下划线分隔：select name, group_concat(id order by id desc separator ‘_’) from table group by name concat(str1, str2)函数：直接拼接，没有分隔符，如果任意一个参数为Null，返回null concat_ws(separator, str1, str2, …)函数：第一个为分隔符，后面为要拼接的属性，比如 select concat_ws(‘,’ , id, name) 多个排序的用法： order by name desc, id asc=&gt; 这里就是先按照name降序，再按照id升序排序 将查询结果中的null赋值：ifnull( 含有null的属性, 要赋的值 )，这里的属性可以是集合函数，比如sum()，举例：(计算完的distance中可能有null值，因为它不存在rides表中，这时候把null变为0)1234567select u.name, ifnull(sum(r.distance), 0) as travelled_distancefrom users uleft join rides ron u.id = r.user_idgroup by r.user_idorder by travelled_distance desc, u.name asc round(想要规范化的数字，位数)函数： 4舍5入到小数点后几位，比如 ROUND(13.145, 2) =&gt; 结果就是13.15 case when end 用法：case [字段] when 表达式 then 显示数据 when 表达式 then 显示数据 else 显示数据 end需要注意的是end不能丢，并且这个语句相当于一个属性，比如：1234567891011121314151617select id, min(case when month = 'jan' then revenue else null end) as Jan_Revenue, =&gt; 意思是如果这个id对应的month里有jan，就输出相应的revenue sum(case when month = 'feb' then revenue else null end) as Feb_Revenue, =&gt; 虽然每个月的费用都只有一条，但是需要聚合函数配合group by，从null和一个数字中把数字选出来 sum(case when month = 'mar' then revenue else null end) as Mar_Revenue, =&gt; 所以min和sum这里的效果一样 sum(case when month = 'apr' then revenue else null end) as Apr_Revenue, =&gt; 具体题目见LC.1179 sum(case when month = 'may' then revenue else null end) as May_Revenue, sum(case when month = 'jun' then revenue else null end) as Jun_Revenue, sum(case when month = 'jul' then revenue else null end) as Jul_Revenue, sum(case when month = 'aug' then revenue else null end) as Aug_Revenue, sum(case when month = 'sep' then revenue else null end) as Sep_Revenue, sum(case when month = 'oct' then revenue else null end) as Oct_Revenue, sum(case when month = 'nov' then revenue else null end) as Nov_Revenue, sum(case when month = 'dec' then revenue else null end) as Dec_Revenuefrom departmentgroup by idorder by id 当需要条件计数，比如计算符合条件的行的个数，单独用count不好使，因为不管你符不符合条件，都会计算在内，除非这条记录是null，比如 count(a = b)，那么不管是否a=b，都会被计数，导致结果出错，这时，需要用到sum(条件)，（注意，这里的sum(条件表达式)表示，如果记录满足条件表达式就加1（而不是加其他值），所以只能统计满足条件的行数）或者用case when语句，比如：12345678910111213select sum(order_date = customer_pref_delivery_date)/count(*) as immediate_percentage from Delivery;# 这里的sum就是计算负荷条件的记录数，如果用count(----)的话，得到的结果永远是1，因为它和count(*)效果一样# 这里还可以用下面这张case when 语句，效果是一样的SELECT sum(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END)/count(*) AS immediate_percentageFROM delivery# 注意：如果让 else 的时候 不是0 而是null，就可以用count来计数了，因为count只是不计算null而已SELECT count(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE null END)/count(*) AS immediate_percentageFROM delivery ### algorithm Morris方法 这个方法是用来做树的中序遍历的（inorder traverse），当然也可以直接recursive，将之前的二叉树变成一个只有右孩子的树，且顺序时inorder的。 已知中序遍历是 左-根-右 的顺序，所以我们的目的是：将“根-右子树”放到左子树的最右边的节点上，直到所有节点都不含有左孩子，从而达到我们的目的。 所以该方法的流程是： 1. 以根节点root为起点，记为当前节点cur; 2. 如果cur不存在左孩子，很好，向下走，将cur节点指向它的右孩子，即cur = cur.right; 否则，找到左子树中最右边的节点（rightmost node），将该节点的右孩子指向当前节点cur，即 rightmost.right = cur，然后当前节点指向它的左孩子，即cur = cur.left; 3. 重复步骤2，直到cur节点为空 经过这样的步骤之后，我们就得到了一个按inorder排列的树，如果需要记录这个遍历，只需要在步骤2的第一个判断条件成立时记录当前节点的值即可。 代码(inorder遍历根节点为root的二叉树，并返回)： 1234567891011121314151617181920212223List&lt;Integer&gt; res = new ArrayList&lt;&gt;();TreeNode cur = root;while(cur != null)&#123; if(cur.left == null) &#123; res.add(cur.val); cur = cur.right; &#125; else &#123; TreeNode pre = cur.left; while(pre.right != null) &#123; pre = pre.right; &#125; pre.right = cur; TreeNode temp = cur; cur = cur.left; temp.left = null; &#125;&#125;return res;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"INTERVIEW","slug":"INTERVIEW","permalink":"http://yoursite.com/tags/INTERVIEW/"},{"name":"FUNDAMENT","slug":"FUNDAMENT","permalink":"http://yoursite.com/tags/FUNDAMENT/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://yoursite.com/tags/PYTHON/"}]},{"title":"读书笔记","slug":"Books","date":"2020-03-29T14:28:11.000Z","updated":"2020-05-15T03:10:04.743Z","comments":true,"path":"2020/03/29/Books/","link":"","permalink":"http://yoursite.com/2020/03/29/Books/","excerpt":"","text":"金字塔原理（The Pyramid Principle） 基本结构：结论先行，以上统下，归类分组，逻辑递进 先重要后次要，先总结后具体，先框架后细节，先结论后原因，先结果后过程，先论点后论据（类似议论文的结构） 听众最常出现的4个问题：是什么，为什么，怎么做，好不好 条理不清的原因：表达思想的顺序和读者的理解力之间的矛盾 “自上而下的表达，自下而上的思考” 自下而上的思考：就是一个不断归类，概括的过程，句子-&gt;段落-&gt;章节-&gt;文章 所有思想必须符合三个规则： 纵向：文章中任一层次的思想必须是下层思想的概括 横向：每组中的思想必须在同一逻辑范畴（检测方法是：能否用单一名字概括这组思想，比如“方法”，“问题”，“建议”） 横向：每组中的思想必须按照逻辑顺序组织 四种组织思想的逻辑顺序： 演绎顺序：大前提，小前提，结论 时间（步骤）顺序：第一，第二，第三 结构（空间）顺序：波士顿，纽约，华盛顿 程度（重要性）顺序：最重要，次要，最不重要 洞穴奇案 有5名探险家被困在一个洞穴里，并得知短时间内无法获救，水尽粮绝，饥寒交迫，于是他们提出，投骰子选出一个牺牲者，让其他四人吃掉这个人的血肉。在最后投掷前，A决定放弃这个方案，可是剩下四个人依然投了骰子，并且恰好选中了A作为牺牲者，而A是这个方案的最初发起人。剩下的四个人在吃掉A之后最终等来了救援，但是他们却被冠以杀人罪，执行了绞刑。那么这四个人到底有没有罪？ 注：概率没有问题，有人替A扔了骰子，并且A也没有提出异议 最初的观点：如果最终的判决是绞刑这4个人，那么这个方案无论如何都是毫无意义的，它将导致所有五个人的死亡。所以，假如这5名探险者当初只有这一个选项，那么遍不应该判处这4名获救者绞刑，因为这样判处的话就相当于毫无理由直接判处了这5个人绞刑。假如这5名探险者还有别的选择，那么A作为这个方案的最初提起者，相当于提出了一个5人全部牺牲的方案，那么A应该对这个决定付出最大的责任，而不是其他4个人。 1 法律规定：“任何人故意剥夺了他人的生命，都必须被判处死刑” 乔布斯传 硅谷最初在60年代末开始飞速发展，原因是军事承包，大量的资金涌入，半导体材料的大规模使用（军事需要），所以叫硅谷","categories":[],"tags":[{"name":"Books","slug":"Books","permalink":"http://yoursite.com/tags/Books/"}]},{"title":"Hexo之路<三>","slug":"How-to-get-this_3","date":"2018-05-17T00:31:11.000Z","updated":"2018-05-17T00:16:20.702Z","comments":true,"path":"2018/05/16/How-to-get-this_3/","link":"","permalink":"http://yoursite.com/2018/05/16/How-to-get-this_3/","excerpt":"","text":"优化next主题的一些操作1. 选择一个主题 theme的选择有很多，这里推荐一个主题网站 这里我选择的是使用人数最多的NEXT主题，参考的文档较多，便于入手 导入hexo主题方法： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 导入成功后，themes文件下会出现一个名为next文件夹，此时只是将next的主题包下载了下来，需要在站点配置文件中设置主题，也就是在站点配置文件中找到theme字段，将它的值改为你的主题名，这里我改为next 1theme: next 2. 两个主要配置文件 在根目录下的_config.yml文件，叫做站点配置文件 在主题目录下也会有一个_config.yml文件，叫做主题配置文件 3. 看下效果 更换主题后，一般要做如下三个操作 123hexo cleanhexo ghexo s 然后打开localhost:4000看看效果，是不是已经变成你的主题了~ 当然，主题中的很多插件都是默认关闭的，需要在之后的配置中根据自己的喜好设置，所以一开始看到的界面会很简单~ 4. 个性化域名 除了在本地演示，博客还可以通过你当时创建的仓库名来访问（你的用户名.github.io），不过每次完成更新后需要 1hexo d 来发布你的更新到服务器上，如果还是没有效果，可以这样： 123hexo cleanhexo ghexo d 来一遍完整的~ 如果觉得github的域名不好记，可以在一些域名网站购买一个喜欢的域名（.com域名最好），我买的域名是mambawang.com 买完域名后，需要与我们的博客网站绑定，先进入博客根目录的source文件中，创建一个名为CNAME的无后缀的文件，内容为你购买的域名 1mambawang.com 这里不需要加www，这样以后加不加www都可以访问你的网站 创建完CNAME文件之后，还要去你购买域名的网站的DNS的管理界面添加以下三条记录，过一会就可以直接输入你的域名访问博客了！ 不过，不知道是什么原因，使用godaddy自带的DNS时老是出问题，后来我把DNS转到DNSPOD上，就再也没出过问题了 记录类型 主机记录 记录值 解析线路 CNAME www 用户名.github.io default A @ 192.30.252.153 default A @ 192.30.252.154 default 5. 未完待续 听点儿歌吧~ 1.头像2.背景透明3.音乐4.网站图标5.超链接语法6.腾讯公益4047.菜单栏添加8.点击爆炸9.背景动画10.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo之路<二>","slug":"How-to-get-this_2","date":"2018-05-16T18:31:11.000Z","updated":"2018-05-17T00:11:57.141Z","comments":true,"path":"2018/05/16/How-to-get-this_2/","link":"","permalink":"http://yoursite.com/2018/05/16/How-to-get-this_2/","excerpt":"","text":"完成基本配置后，怎么让我们的博客更好看？1. 选择一个主题 theme的选择有很多，这里推荐一个主题网站 这里我选择的是使用人数最多的NEXT主题，参考的文档较多，便于入手 导入hexo主题方法： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 导入成功后，themes文件下会出现一个名为next文件夹，此时只是将next的主题包下载了下来，需要在站点配置文件中设置主题，也就是在站点配置文件中找到theme字段，将它的值改为你的主题名，这里我改为next 1theme: next 2. 两个主要配置文件 在根目录下的_config.yml文件，叫做站点配置文件 在主题目录下也会有一个_config.yml文件，叫做主题配置文件 3. 看下效果 更换主题后，一般要做如下三个操作 123hexo cleanhexo ghexo s 然后打开localhost:4000看看效果，是不是已经变成你的主题了~ 当然，主题中的很多插件都是默认关闭的，需要在之后的配置中根据自己的喜好设置，所以一开始看到的界面会很简单~ 4. 个性化域名 除了在本地演示，博客还可以通过你当时创建的仓库名来访问（你的用户名.github.io），不过每次完成更新后需要 1hexo d 来发布你的更新到服务器上，如果还是没有效果，可以这样： 123hexo cleanhexo ghexo d 来一遍完整的~ 如果觉得github的域名不好记，可以在一些域名网站购买一个喜欢的域名（.com域名最好），我买的域名是mambawang.com 买完域名后，需要与我们的博客网站绑定，先进入博客根目录的source文件中，创建一个名为CNAME的无后缀的文件，内容为你购买的域名 1mambawang.com 这里不需要加www，这样以后加不加www都可以访问你的网站 创建完CNAME文件之后，还要去你购买域名的网站的DNS的管理界面添加以下三条记录，过一会就可以直接输入你的域名访问博客了！ 不过，不知道是什么原因，使用godaddy自带的DNS时老是出问题，后来我把DNS转到DNSPOD上，就再也没出过问题了 记录类型 主机记录 记录值 解析线路 CNAME www 用户名.github.io default A @ 192.30.252.153 default A @ 192.30.252.154 default 5. 未完待续 听点儿歌吧~","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"http://yoursite.com/tags/Github-Pages/"}]},{"title":"Hexo之路<一>","slug":"How-to-get-this_1","date":"2018-05-08T18:31:11.000Z","updated":"2018-05-16T21:59:13.498Z","comments":true,"path":"2018/05/08/How-to-get-this_1/","link":"","permalink":"http://yoursite.com/2018/05/08/How-to-get-this_1/","excerpt":"","text":"1. 基本环境 &amp; 配置（具体如何配置环境请自行google） 检查Node.js &amp; npm 环境 检查Git环境 2. 在Github上创建代码库（用于上传blog代码） 在github中创建一个新的repository，这个仓库的名字要用yourname.github.io这个形式 例如: 你的github用户名叫ABC，那么仓库名必须为ABC.github.io，其他参数都默认即可 3. 配置Hexo 在你的PC上创建一个新文件夹，今后的所有操作都只在这个文件夹中进行（网站的所有文件都在这个文件夹中） 打开这个空文件夹，空白处 shift + 鼠标右键，输入 1hexo init 进行初始化工作，要注意的是初始化只有在空文件夹下才起作用 继续输入 1npm install hexo-cli -g 会出现一些warn，不用管它们 继续输入 1npm install hexo --save 到这里hexo的环境应该已经配置好了，输入 1hexo -v 来检查hexo环境，如果出现一堆版本信息，则说明配置成功 4. 初始化Hexo 接着上面输入 1hexo init 不过，如果这时你的文件夹不是空的就不用输入这一行了 继续输入 1npm install 完成初始化 5. 初步体验Hexo 继续输入 1hexo -g 最后输入 1hexo -s 浏览器中输入localhost:4000，可以看到一个初步的Hexo页面，格式都是Hexo为我们自动生成的，可以修改 6. 未完待续 听点儿歌吧~","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"http://yoursite.com/tags/Github-Pages/"}]},{"title":"Markdown文章示例","slug":"Untitled Document","date":"2018-05-07T16:55:11.000Z","updated":"2018-05-13T22:34:04.643Z","comments":true,"path":"2018/05/07/Untitled Document/","link":"","permalink":"http://yoursite.com/2018/05/07/Untitled Document/","excerpt":"","text":"Dillinger Dillinger is a cloud-enabled, mobile-ready, offline-storage, AngularJS powered HTML5 Markdown editor. Type some Markdown on the left See HTML in the right Magic New Features! Import a HTML file and watch it magically convert to Markdown Drag and drop images (requires your Dropbox account be linked) You can also: Import and save files from GitHub, Dropbox, Google Drive and One Drive Drag and drop markdown and HTML files into Dillinger Export documents as Markdown, HTML and PDF Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As John Gruber writes on the Markdown site The overriding design goal for Markdown’sformatting syntax is to make it as readableas possible. The idea is that aMarkdown-formatted document should bepublishable as-is, as plain text, withoutlooking like it’s been marked up with tagsor formatting instructions. This text you see here is actually written in Markdown! To get a feel for Markdown’s syntax, type some text into the left window and watch the results in the right. TechDillinger uses a number of open source projects to work properly: AngularJS - HTML enhanced for web apps! Ace Editor - awesome web-based text editor markdown-it - Markdown parser done right. Fast and easy to extend. Twitter Bootstrap - great UI boilerplate for modern web apps node.js - evented I/O for the backend Express - fast node.js network app framework @tjholowaychuk Gulp - the streaming build system Breakdance - HTML to Markdown converter jQuery - duh And of course Dillinger itself is open source with a public repository on GitHub. InstallationDillinger requires Node.js v4+ to run. Install the dependencies and devDependencies and start the server. 123$ cd dillinger$ npm install -d$ node app For production environments… 12$ npm install --production$ NODE_ENV=production node app PluginsDillinger is currently extended with the following plugins. Instructions on how to use them in your own application are linked below. Plugin README Dropbox plugins/dropbox/README.md Github plugins/github/README.md Google Drive plugins/googledrive/README.md OneDrive plugins/onedrive/README.md Medium plugins/medium/README.md Google Analytics plugins/googleanalytics/README.md DevelopmentWant to contribute? Great! Dillinger uses Gulp + Webpack for fast developing.Make a change in your file and instantanously see your updates! Open your favorite Terminal and run these commands. First Tab:1$ node app Second Tab:1$ gulp watch (optional) Third:1$ karma test Building for sourceFor production release:1$ gulp build --prod Generating pre-built zip archives for distribution:1$ gulp build dist --prod DockerDillinger is very easy to install and deploy in a Docker container. By default, the Docker will expose port 8080, so change this within the Dockerfile if necessary. When ready, simply use the Dockerfile to build the image. 12cd dillingerdocker build -t joemccann/dillinger:$&#123;package.json.version&#125; This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out ${package.json.version} with the actual version of Dillinger. Once done, run the Docker image and map the port to whatever you wish on your host. In this example, we simply map port 8000 of the host to port 8080 of the Docker (or whatever port was exposed in the Dockerfile): 1docker run -d -p 8000:8080 --restart=\"always\" &lt;youruser&gt;/dillinger:$&#123;package.json.version&#125; Verify the deployment by navigating to your server address in your preferred browser. 1127.0.0.1:8000 Kubernetes + Google CloudSee KUBERNETES.md Todos Write MORE Tests Add Night Mode LicenseMIT Free Software, Hell Yeah!","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"http://yoursite.com/tags/Github-Pages/"}]},{"title":"Daily","slug":"Daily","date":"2018-04-03T14:52:14.000Z","updated":"2020-05-12T22:25:19.765Z","comments":true,"path":"2018/04/03/Daily/","link":"","permalink":"http://yoursite.com/2018/04/03/Daily/","excerpt":"","text":"水深火热： 前一天中午虐猫的那个人不关煤气，关键是他人还在客厅，都闻不到，后一天另一个室友不关火，我都是在自己屋里忍无可忍才出来检查一下，我能活到现在真是个奇迹。 从来不关门，开完冰箱不关冰箱门，下楼不关房门，我半夜起来关门不下20次了已经，最近还说因为疫情这边会有抢劫的情况，也不知你说这个话的时候知不知道自己到底在说什么 一个idea 相处一个idea，符合自己的兴趣，有意义，有趣，选好一个目标：篮球，留学生，疫情idea1 疫情期间航线查询 2020-05-10 读乔布斯传 突然发现应该少看知乎，至少在自己能够独立思考之前，不然总是会在遇到问题时第一时间去知乎，而放弃了自己的思考 看到有人把乔布斯的病和他的素食主义关联到一起，想到了之前上过的一门课，因果推论，虽然很多时候因和果存在一定的时间关系，但并不一定A发生在B之前，A就是B的原因 有可能C也发生在B之前，C才是B的真正原因，而A和B实际上没什么关系对于因果是否存在时间关系，举个例子，总的来看，高学历可以获得更高的工资，但同时，也意味着要获得高工资，你需要更高的学历，从而形成了一种双向的因果。 聪明，智慧，迷茫，孤僻，固执，嬉皮士，素食，辍学，印度，禅宗，修行， 可以编写一个手册，记录我目前的状态到最终找到工作的一个过程。idea的来源是github上的一个外国小哥自学8个月进amazon的经历 可以把知识点变成知识卡，做成答题游戏（记忆卡，flash card） 一万小时定律：人们眼中的天才并非是人们所见的那样，天资超凡，一个人在任何一个领域从平凡变成非凡都要经历10000小时的持续努力（一万小时是从平凡到非凡的必须的锤炼）。要成为某个领域的专家，需要10000小时，按比例计算就是如果每天8小时的学习，一周工作5天，则需要至少5年。","categories":[],"tags":[{"name":"Daily","slug":"Daily","permalink":"http://yoursite.com/tags/Daily/"}]},{"title":"Log","slug":"Log","date":"2018-03-27T15:02:14.000Z","updated":"2020-05-12T22:36:58.771Z","comments":true,"path":"2018/03/27/Log/","link":"","permalink":"http://yoursite.com/2018/03/27/Log/","excerpt":"","text":"不能上传文章问题，解决办法：更新git版本，更改配置文件deploy中的repo地址 还有小问题是每次上传都要输密码，解决办法： 加入左下角的动画人物步骤：获取live2d npm install –save hexo-helper-live2d ; 导入所需图形 npm install live2d-widget-model-shizuku ; 在站点配置文件下添加： live2d的代码 更改鼠标样式尝试了一上午， 失败 想写一个网页计数器，记录学习时间，看到一个不错的，搞了半天最后发现它其实用的是一个动画效果来展示时间，放弃 setTimeout是JavaScript中的函数，用于延时执行某个函数，参数第一个为函数名或代码段，第二个为延时（ms） hexo本来就是静态的博客，所以把所有数据都存在本地即可，没必要浪费时间在这上","categories":[],"tags":[{"name":"log","slug":"log","permalink":"http://yoursite.com/tags/log/"}]}]}